
# hadoop_the_definitive_guide.md  Hadoop权威指南  



# 第14章 ZooKeeper  

ZooKeeper是Hadoop的分布式协调服务.  

写分布式应用的难点在于出现"部分失败".  

## ZooKeeper特点  

- ZooKeeper是简单的. ZooKeeper的核心是一个精简的文件系统, 它提供一些简单的操作和一些额外的抽象操作. 例如排序和通知.  
- ZooKeeper是富有表现力的. ZooKeeper的基本操作是一组丰富的"构件"(building block), 可以实现多种协调数据结构和协议.  
- ZooKeeper具有高可用性. ZooKeeper运行在一组机器之上, 并且在设计上具有高可用性, 因此应用程序可以完全依赖与它.  
- ZooKeeper采用松耦合交互方式. 在ZooKeeper支持的交互过程中, 参与者不需要彼此了解.  
- ZooKeeper是一个资源库. ZooKeeper提供了一个通用协调模式实现方法的开源共享库, 使程序员免于编写这类通用的协议(这通常是很难写正确的).  

## 安装和运行ZooKeeper  

```  

% tar -xzf zookeeper-x.y.z.tar.gz

% export ZOOKEEPER_INSTALL=/home/zookeeper-x.y.zookeeper-x
% export PATH=$PATH:$ZOOKEEPER_INSTALL/bin

zoo.cfg
tickTime=2000
dataDir=/Users/highill/zookeeper-x
clientPort=2181


% zkServer.sh start

% echo ruok | nc localhost 2181




```  


理解ZooKeeper的一种方式就是将其看作一个具有高可用性特征的文件系统. 这个文件系统中没有文件和目录, 而是统一使用"节点"(node)的概念, 称为znode. znode即可以作为保存数据的容器(如同文件), 也可以作为保存其他znode的容器(目录).  

有两种类型的znode: 短暂的(ephemeral)和持久的(persistent). 创建znode客户端断开连接时, 无论客户端是明确断开还是因为任何原因而终止, 短暂znode都会被ZooKeeper服务删除. 与之相反, 当客户端断开时, 持久znode不会被删除.  

ZooKeeper类提供了一个delete()方法, 该方法有两个参数: 节点路径和版本号. 如果所提供的版本号与znode的版本号一致, ZooKeeper会删除这个znode. 这是一种乐观的加锁机制. 使客户端能够检测出对znode的修改冲突. 通过将版本号设置为-1. 可以绕过这个版本检测机制, 不管znode的版本号是什么而直接将其删除.  
ZooKeeper不支持递归的删除操作, 因此在删除父节点之前必须先删除子节点.  

ZooKeeper维护着一个树形层次结构, 树中的节点被称为znode. znode可以用于存储数据, 并且有一个与之关联的ACL.  ZooKeeper被设计用来实现协调服务(这类服务通常使用小数据文件), 而不是用于大容量数据存储, 因此一个znode能够存储的数据被限制在1MB以内.  

ZooKeeper的数据访问具有原子性. 客户端在读取一个znode的数据时, 要么读到所有的数据, 要么读操作失败, 不会只读到部分数据.  

ZooKeeper中的路径必须是绝对路径, 也就是说每条路径必须从一个斜杠字符开始. 此外, 所有的路径表示必须是规范的, 即每条路径只有唯一的一种表示方式, 不支持路径解析. 如Unix中, 一个具有路径` /a/b ` 的文件也可以通过路径 ` /a/./b ` 来表示, 原因在于 "." 在Unix表示当前目录. 在ZooKeeper中, "."不具有这种特殊含义.  
ZooKeeper使用 /zookeeper子树来保存管理信息, 例如关于配额的信息.  

znode有两种类型: 短暂的和持久的.  短暂的znode不可以有子节点, 即使是短暂的子节点.  虽然每个短暂的znode会被绑定到一个客户端, 但它们对所有客户端还是可见的(当然, 还要符合ACL的定义).  


顺序(sequential) znode是指名称中包含ZooKeeper指定顺序号的znode. 如果在创建znode时设置了顺序标识, 那么该znode名称之后便会附加一个值, 这个值是由一个单调递增的计数器(由父节点维护)所添加的.  

在一个分布式系统中, 顺序号可以被用于为所有的事件进行全局排序, 这样客户端就可以通过顺序号来推断事件的顺序.  


znode以某种方式变化时, "观察"(watch)机制可以让客户端得到通知. 观察只能被触发一次, 对于连接事件的回调除外, 这种观察不需要重新注册. 为了能够多次收到通知, 客户端需要重新注册所需的观察.  


ZooKeeper中有9中基本操作  

```  
create  
delete  
exists  
getACL,  setACL  
getChildren  
getData,  setData  
sync  



```  

虽然ZooKeeper可以被看作是一个文件系统, 但出于简单性的需要, 有一些文件系统的基本操作被它摒弃了. 由于ZooKeeper中的文件较小并且总是被整体读写, 因此没有必要提供打开, 关闭或查找操作.  

ZooKeeper中有一个被称为multi的操作. 用于将多个操作集合合成一个操作单元, 并确保这些操作同时被执行成功, 或者同时失败, 不会发生其中部分基本操作被成功执行而其它基本操作失败的情况. 集合更新可以被用于在ZooKeeper中构建需要保持全局一致性的数据结构, 例如构建一个无向图.  


对于ZooKeeper客户端来说, 主要有两种语言绑定(binding)可以使用: Java和C. 当然也可以使用Perl, Python和 REST的contrib绑定. 对于每一种绑定语言来说, 在执行操作时都可以选择同步执行或异步执行.  

因为所有异步操作的结果都是通过回调来传送的, 因此在Java API中异步方法的返回类型都是void. 调用者传递一个回调的实现, 当ZooKeeper响应时, 该方法被调用. 在这种情况下, 回调采用StatCallback接口.  

实际上, 有两个C语言的共享库. 单线程库zookeeper_st只支持异步API, 并且主要在没有pthread库或pthread库不稳定的平台上使用. 大部分开发人员都是用多线程库zookeeper_mt, 它既支持同步API, 也支持异步API.  

如果习惯于事件驱动的编程模型, 则异步API更合适些.  


在exists, getChildren和getData这些操作上可以设置观察, 这些观察可以被写操作 create, delete, setData触发. ACL相关的操作不会参与触发任何观察.  

- 当所观察的znode被创建, 删除或其数据被更新时, 设置在exists操作上的观察将被触发.  
- 当所观察的znode被删除或其数据更新时, 设置在getData操作上的观察将被触发. 创建znode不会触发getData操作上的观察, 因为getData操作成功执行的前提是znode必须存在.  
- 当所观察的znode的一个子节点被创建或删除时, 或所观察的znode自己被删除时, 设置在getChildren操作上的观察将会被触发. 可以通过观察事件的类型来判断被删除的是znode还是其子节点: NodeDelete类型代表znode被删除; NodeChildrenChanged类型代表一个子节点被删除.  


观察及其触发操作所对应的时间类型  

<table>
    <tr>
	    <th rowspan="2">设置观察的操作</th>    <th colspan="5"> 观察触发器</th>
	</tr>
	<tr>
	    <th>创建znode</th>    <th>创建子节点</th>    <th>删除znode</th>    <th>删除子节点</th>    <th>setData</th> 
	</tr>
	
	
	<tr>
	    <td>exists</td>    <td>NodeCreated</td>    <td></td>    <td>NodeDeleted</td>    <td></td>    <td>NodeDataChanged</td>
	</tr>
	<tr>
	    <td>getData</td>    <td></td>    <td></td>    <td>NodeDeleted</td>    <td></td>    <td>NodeDataChanged</td>
	</tr>
	<tr>
	    <td>getChildren</td>    <td></td>    <td>NodeChildrenChanged</td>    <td>NodeDeleted</td>    <td>NodeChildrenChanged</td>    <td></td>
	</tr>
	
</table>


一个观察事件中包含涉及该事件的znode的路径. 因此对于NodeCreated和NodeDeleted事件来说, 可通过路径判断哪一个节点被创建或删除.  为了能够在NodeChildrenChanged事件发生后判断是哪些子节点被修改, 需要重新调用getChildren来获取新的子节点列表. 与之类似, 为了能够在NodeDataChanged事件之后获取新的子节点列表, 需要调用getData.  


每个znode被创建时都会带一个ACL列表. ACL依赖于ZooKeeper的客户端验证机制. ZooKeeper提供了以下几种身份验证方式:  
- Digest  通过用户名和密码来识别客户端  
- sasl  通过Kerberos来识别客户端  
- Ip  通过客户端IP地址来识别客户端  


exists操作不受ACL权限的限制, 因此客户端可以调用exists来检索一个znode的状态或查询一个znode是否存在.  


ACL权限  

<table>
    <tr>
	    <th>ACL权限</th>    <th>允许的操作</th>    
	</tr>
	
	<tr>
	    <td>CREATE</td>    <td>create(子节点)</td>    
	</tr>
	<tr>
	    <td rowspan="2">READ</td>    <td>getChildren</td>    
	</tr>
	<tr>
	    <td>getData</td>    
	</tr>
	<tr>
	    <td>WRITE</td>    <td>setData</td>    
	</tr>
	<tr>
	    <td>DELETE</td>    <td>delete(子节点)</td>    
	</tr>
	<tr>
	    <td>ADMIN</td>    <td>setACL</td>    
	</tr>
</table>  



ZooDefs.Ids中有一些预定义的ACL, OPEN_ACL_UNSAFE是其中之一, 它将所有的权限(不包括ADMIN权限)授予每个人.  

此外, ZooKeeper还支持插入式身份验证机制, 如果需要的话, 它可以集成第三方的身份验证系统.  


## ZooKeeper实现  

ZooKeeper服务有两种不同的运行模式．　一种是"独立模式"(standalone mode), 即只有一个ZooKeeper服务器．　这种模式比较简单，　比较适合测试环境(甚至可以在单元测试中采用), 但是这种模式不能保证高可用性和可恢复性．　在生产环境中的ZooKeeper通常以"复制模式"(replicated mode)运行于一个计算机集群上，　这个计算机集群被称为一个"集合体"(ensemble).  只有集合体中半数以上的机器处于可用状态，　它就能提供服务. 例如5个节点的集合体中, 任意2台服务出现故障, 都可以保证服务继续, 因为剩下的3台超过了半数. 6个节点的集合体也只能容忍2台机器故障, 因为如果３台机器出现故障, 剩下的3台机器没有超过集合体的半数.  一个集合体通常包含奇数台机器.  

如果少于半数的机器出现故障, 则最少有一台机器会保存最新的状态, 其余的副本最终也会更新到这个状态.  

ZooKeeper使用了Zab协议, 该协议包括了两个可以无限重复的阶段.  

1. 阶段1 领导者选举  
集合体中的所有机器通过一个选择过程来选出一台被称为"领导者"(leader)的机器. 其它的机器被称为"跟随着"(follower). 一旦半数以上(或指定数量)的跟随着已经将其状态与领导者同步, 则表明这个阶段已经完成.  

2. 阶段2 原子广播  
所有的写请求都会被转发给领导者, 再由领导者将更新广播给跟随者. 当半数以上的跟随着已经将修改持久化之后, 领导者才会提交这个更新. 然后客户端才会收到一个更新成功的响应.  

ZooKeeper是否使用Paxos? 否. ZooKeeper的Zab协议不同于众所周知的Paxos算法(Leslie Lamport, "Paxos Made Simple" ACM SIGACT News[Distributed Computing Column]). Google的Chubby锁服务是基于Paxos的.  


如果领导者出现故障, 其余的机器会选出另外一个领导者, 并和新的领导者一起继续提供服务. 随后, 如果之前的领导者恢复正常, 会成为一个跟随着. 领导者选举的过程是非常快的, 根据一个已公布的结果来看, 只需要大概200毫秒, 因此在领导者选举的过程中不会出现系统性能明显降低.  

在更新内存中的znode之前, 集合体中的所有机器都会先将更新写入磁盘. 任何一台机器都可以为读请求提供服务. 并且由于读请求只涉及内存检索, 因此非常快.  

一个跟随着可能滞后领导者几个更新. 这也表明在一个修改被提交前, 只需要集合体中半数以上机器已经将该修改持久化即可.  

每一个对znode树的更新都被赋予一个全局唯一的ID, 称为zxid(代表ZooKeeper Transaction ID). ZooKeeper要求所有的更新进行编号并排序, 它决定了分布式系统的执行顺序.  


在ZooKeeper的设计中, 以下几点保证了数据的一致性.  
- 1. 顺序一致性  来自任意特定客户端的更新都会按照其发送顺序被提交.  
- 2. 原子性  每个更新要么成功, 要么失败. 这意味着如果一个更新失败, 则不会有客户端看到这个更新的结果.  
- 3. 单一系统映像  一个客户端无论连接到哪一台服务器, 它看到的都是同样的系统视图. 这意味着, 如果一个客户端在同一个会话中连接到一台新的服务器, 它所看到的系统状态不会比之前服务器上所看到的更老.  
- 4. 持久性  一个更新一旦成功, 其结果会持久存在并且不会被撤销. 这表明更新不会受到服务器故障的影响.  
- 5. 及时性  任何客户端所看到的滞后系统视图都是有限的, 不会超过几十秒. 如果客户端之间通过ZooKeeper之外的机制进行通信, 则客户端可能发现他们所看到的ZooKeeper状态是不一致的.  


sync操作只能以异步的方式被调用. 你不需要等待sync调用的返回, ZooKeeper会保证任何后续的操作都在服务器的sync操作完成后才执行, 哪怕这些操作是在sync操作完成之前发出的.  

每个ZooKeeper客户端的配置中都包括集合体中服务器的列表. 在启动时, 客户端会尝试连接到列表中的一台服务器. 如果连接失败, 它会尝试连接到另一台服务器, 以此类推, 直到成功与一台服务器建立连接或因为所有ZooKeeper服务器都不可用而失败.  

一旦客户端与一台ZooKeeper服务器建立连接, 这台服务器就会为该客户端创建一个新的会话. 会话通常都会长期存在, 而会话过期则是一种比较罕见的事件, 但对于应用来说, 如何处理会话过期仍是非常重要的.  

只要一个会话空闲超过一定时间, 都可以通过客户端发送ping请求(也称为心跳)来保持会话不过期.(ping请求是由ZooKeeper的客户端自动发送. 因此你在代码里不需要考虑如何维护会话).  

ZooKeeper客户端可以自动地进行故障切换, 切换到另一台ZooKeeper服务器, 并且关键的是, 在另一台服务器接替故障服务器之后, 所有的会话(和相关的短暂znode)仍然是有效的.  

在故障切换过程中, 应用程序将收到断开连接和连接至服务的通知. 当客户端断开连接时, 观察通知将无法发送; 但是客户端成功恢复连接后, 这些延迟的通知还会被发送. 当然, 在客户端重新连接至另一台服务器的过程中, 如果应用程序试图执行一个操作, 这个操作将会失败. 这充分说明在真实的ZooKeeper应用中处理连接丢失异常的重要性.  


## ZooKeeper的时间参数  

"滴答"(tick time) 参数定义了ZooKeeper中的基本时间周期, 并被集合体中的服务器用来定义相互交互的时间表. 其他设置都是根据滴答参数来定义的, 或至少受它限制. 例如, 会话时间超时(session timeout)参数的值不可以小于2个滴答并且不可以大于20个滴答. 如果你试图将会话超时参数设置在这个范围之外, 它将会被自动修改到这个范围之内.  

通常将滴答参数设置为2秒(2000毫秒), 对应于允许的会话超时范围是4到40秒.  

较短的会话超时设置会较快地检测到机器故障. 要避免将会话超市时间设得太低, 因为繁忙的网络会导致数据包延迟, 从而可能会无意导致会话过期. 在这种情况下, 机器可能出现"振动"(flap)现象: 在很短的时间内反复出现离开后又重新加入组的情况.  

对于那些创建较复杂暂时状态的应用程序来说, 由于重建的代价较大, 因此比较适合设置较长的会话超时.  

将会话ID和密码保存在稳定的存储器中之后, 可以将一个应用程序正常关闭, 然后在重启应用之前凭借所保存的会话ID和密码来恢复会话环境.  

可以将这个特征看成是一种用来帮助避免会话过期的优化技术, 但不能因此忽略对会话过期异常的处理, 因为机器的意外故障也会导致会话过期, 或者, 即使应用程序是正常关闭, 也有可能因任何原因导致它没有在会话过期之前完成重启.  

一般规则是, ZooKeeper集合体中的服务器越多, 会话超时的设置应越大. 连接超时, 读超时和ping周期都被定义为集合体中服务器数量的函数, 因此集合体中服务器数量越多, 这些参数的值反而越小. 如果频繁遇到连接丢失的情况, 应考虑增大超时的设置.  

ZooKeeper对象在其生命周期中会经历几种不同的状态, 可以在任何时刻通过getState()方法来查询对象的状态.  

ZooKeeper的Watcher对象肩负双重责任: 一方面它可以被用于获得ZooKeeper状态变化的相关通知; 另一方面还以被用于获得znode变化的通知. 监视znode的变化可以使用一个专用的观察对象(将其传递给适当的读操作), 也可以通过读操作中的布尔标识来设定是否使用默认的观察.   

ZooKeeper实例可以断开然后重新连接到ZooKeeper服务, 此时它的状态就在CONNECTED和CONNECTING之间转换. 如果它断开连接, 观察会收到一个Disconnected事件. 注意, 这些状态转换都是由ZooKeeper实例自己发起的, 如果连接丢失, 它会自动尝试重新连接.  

close()方法被调用或出现会话超时(观察事件的KeeperState值为Expired)时, ZooKeeper实例会转换到第三个状态CLOSED. 一旦处于CLOSED状态, ZooKeeper对象不再被认为是活跃的(可以对States使用isAlive()方法来测试). 并且不能再用. 为了重新连接到ZooKeeper服务, 客户端必须创建一个新的ZooKeeper实例.  


## 使用ZooKeeper构建应用  

### 配置服务  
ZooKeeper可以作为一个具有高可用性的配置存储器, 允许分布式应用的参与者检索和更新配置文件.  

通过两个假设来简化所需实现的服务(稍加修改就可以取消这两个假设). 第一, 我们唯一需要存储的配置数据是字符串, 关键字是znode的路径, 因此我们在每个znode上存储了一个键/值对. 第二, 在任何时候只有一个客户端会执行更新操作.除此之外, 这个模型看起来就像是有一个主人(类似于HDFS中的namenode)在更新信息, 而他的工人则需要遵循这些信息.  

### 可复原的ZooKeeper应用  

关于分布式计算的第一个误区是"网络是可靠的". 因此当程序运行那个在真正的网络时, 往往会出现各种各样的故障.  

在Java API中的每一个ZooKeeper操作都在其throws 子句中声明了两种类型的异常, 分别是InterruptedException和KeeperException.  

1. InterruptedException异常  

如果操作被中断, 则会有一个InterruptedException异常被抛出. 在Java语言中有一个阻塞方法的标准机制, 即针对存在阻塞方法的线程调用interrupt(). 一个成功的取消操作将产生一个InterruptedException异常.  

InterruptedException异常并不意味着有故障, 而是表明相应的操作已经被取消.  

2. KeeperException异常  

如果ZooKeeper服务器发出了一个错误信号或与服务器存在通信问题, 抛出的则是KeeperException异常.  
每一个KeeperException异常的子类都对应一个关于错误类型信息的代码.  

有两种方法用来处理KeeperException异常: 一种是捕捉KeeperException异常并且通过检测它的代码来决定采取何种补救措施; 另一种是捕捉等价的KeeperException子类并且在每段捕捉代码中执行相应的操作.  

KeeperException异常分为三大类:  

**状态异常**  当一个操作因不能被应用于znode树而导致失败时, 就会出现状态异常. 状态异常产生的原因通常是在同一时间有另外一个进程正在修改znode.  
**可恢复的异常**  可恢复的异常是指那些应用程序能够在一个ZooKeeper会话中恢复的异常.  一个可恢复的异常是通过KeeperException.ConnectionLossException来表示的, 它意味着已经失去了与ZooKeeper的连接. ZooKeeper会尝试重新连接, 并且在大多数情况下重新连接会成功, 并确保会话是完整的.  

ZooKeeper不能判断与KeeperException.ConnectionLossException异常相关的操作是否成功执行. 这种情况就是部分失败的一个例子. 这时程序员有责任来解决这种不确定性, 并且根据应用的情况来采取适当的操作.  
需要对"幂等"(idempotent)操作和"非幂等"(Nonidempotent)操作进行区分. 幂等操作是指那些一次或多次执行都会产生相同结果的操作. 例如读请求或无条件执行的setData操作. 对于幂等操作, 只需要简单地进行重试.  
对于非幂等操作, 就不能盲目地进行重试, 因为它们多次执行的结果与一次执行是完全不同的. 程序可以通过在znode的路径和它的数据中编码信息来检测是否非幂等操作的更新已经完成.  

**不可恢复的异常**  在某些情况下, ZooKeeper会话失效 - 也会因为超时或因为会话被关闭(两种情况下都会收到KeeperException.SessionExpiredException异常), 或因为身份验证失败(KeeperException.AuthFailedException异常). 


### 可靠的配置服务  

设置了重试的最大次数MAX_RETRIES和两次重试之间的时间间隔RETRY_PERIOD_SECOND.  


当一个会话过期时, ZooKeeper对象会进入CLOSED状态, 此状态下它不能再进行重新连接. 只是简单地将这个异常重新抛出并且让调用者创建一个新的ZooKeeper实例, 以重试整个write()方法.  
处理会话过期的另一种方式是在观察中监测类型为Expired的KeeperState, 然后在监测到的时候创建一个新的连接.  

这里忽略了另一种故障模式, 当ZooKeeper对象被创建时, 它会尝试连接一个ZooKeeper服务器. 如果连接失败或超时, 那么它会尝试连接集合体中的另一台服务器. 如果在尝试集合体中所有服务器之后仍然无法建立连接, 它会抛出一个IOException异常. 由于所有ZooKeeper服务器都不可用的可能性很小, 所以一些应用程序选择循环重试操作, 直到ZooKeeper服务可用为止.  


还有很多其他策略, 例如使用"指数退回"(exponential backoff), 每次将重试的间隔乘以一个常数. Hadoop内核中的org.apache.hadoop.io.retry包是一组工具, 能够以可重用的方式将重试逻辑加入用户代码, 因此对于构建ZooKeeper应用是非常有用的.  

### 锁服务  

分布式锁能够在一组进程之间提供互斥机制, 使得在任何时刻只有一个进程可以持有锁. 分布式锁可以用于在大型分布式系统中实现领导者选举, 在任何时间点, 持有锁的那个进程就是系统的领导者.  

不要将ZooKeeper自己的领导者选举和使用ZooKeeper基本操作实现的一般的领导者选举服务混为一谈(事实上, ZooKeeper中包含有一个领导者选举服务的实现). ZooKeeper自己的领导者选举机制是不对外公开的.  

为了使用ZooKeeper来实现分布式锁服务, 我们使用顺序znode来为那些竞争锁的进程强制排序.  首先指定一个作为锁的znode, 通常用它来描述被锁定的实体, 称为/leader; 然后希望获得锁的客户端创建一些短暂顺序znode, 作为锁znode子节点. 在任何时间, 顺序号最小的客户端将持有锁. ZooKeeper服务是顺序的仲裁者, 因为它负责分配顺序号.  

通过删除znode /leader/lock-1即可简单地将锁释放; 另外, 如果客户端进程死亡, 对应的短暂znode也会被删除. 接下来, 创建/leader/lock-2的客户端将持有锁, 因为它的顺序号紧跟前一个. 通过创建一个关于znode删除的观察, 可以使客户端在获得锁时得到通知.  

**1. 羊群效应**  
"羊群效应"(herd effect)  
在有成百上千客户端的情况, 所有的客户端都在尝试获得锁, 所以每个客户端都会在锁znode上设置一个观察, 用于捕捉子节点的变化. 每次锁被释放或一个新进程开始申请锁的时候, 观察都会被触发并且每个客户端都会收到通知. "羊群效应"就是指这种大量客户端收到同一事件的通知, 但实际上只有很少一部分需要处理这一事件. 在这种情况下, 只有一个客户端会成功地获得锁, 但是维护的过程以及向所有客户端发送观察事件会产生峰值流量, 这会对ZooKeeper服务器造成压力.  

为了避免出现羊群效应, 需要优化发送通知的条件. 关键在于仅当前一个顺序号的子节点消失时才需要通知下一个客户端, 而不是删除(或创建)任何子节点时都进行通知.  

**2. 可恢复的异常**  
由于创建一个顺序znode是非幂等操作, 所以不能简单地进行重试. 原因在于如果第一次创建已成功, 重试会多出一个永远删除不掉的孤儿znode(至少到客户端会话结束前). 最不幸的结果是还将会出现死锁.  

客户端会话的ID是一个长整数, 并且在ZooKeeper服务中是唯一的, 因此非常适合在连接丢失后用于重新识别客户端. 可以通过调用Java ZooKeeper类的getSessionId()方法来获得会话的ID.  

再创建短暂顺序znode时应当采用 ` lock-<sessionId>- `这样的命名方式, ZooKeeper在其尾部添加顺序号之后, znode的名称会形如 ` lock-<sessionId>-<sequenceNumber> `. 由于顺序号对于父节点来说是唯一的, 但对于子节点名并不唯一, 因此采用这样的命名方式可以让子节点在保持创建顺序的同时能够唯一确定自己的创建者. 

**3. 不可恢复的异常**  

如果一个客户端的ZooKeeper会话过期, 那么它所创建的短暂znode将会被删除, 已持有的锁会被释放. 或者是放弃了申请锁的位置. 锁是不能预知应用程序需要如何清理自己的状态.  

**4. 实现**  

ZooKeeper带有一个Java语言编写的生产级别的锁实现, 名为WriteLock, 客户端可以很方便地使用它.  


### 更多分布式数据结构  

使用ZooKeeper可以实现很多不同的分布式数据结构和协议, 例如"屏障"(barrier), 队列和两阶段提交协议. 有趣的是它们都是同步协议, 但可以使用异步ZooKeeper基本操作(如通知)来实现它们.  

ZooKeeper网站(http://zookeeper.apache.org)提供了一些用于实现分布式数据结构和协议的伪代码. ZooKeeper本身也带有一些标准方法的实现(包括锁, 领导者选举和队列), 放在安装位置下的` receipes `目录中.  

Curator项目(https://github.com/Netflix/curator)提供了更多的ZooKeeper方法的实现.  


**BookKeeper和Hedwig**  

BookKeeper是一个具有高可用性和可靠性的日志服务. 它可以用来实现预写式日志(write-ahead logging), 这是一项在存储系统中用于保证数据完整性的常用技术.  

BookKeeper客户端所创建的日志被称为ledger, 每一个添加到ledger的记录被称为ledger entry. 每个ledger entry就是一个简单的字节数组. ledger由保存有ledger数据副本的bookie服务器组进行管理. ledger数据不存储在ZooKeeper中, 只有元数据保存在ZooKeeper中.  

通过提供具有高可用性的日志服务, BookKeeper承诺了提供透明的故障恢复, 因为它可以容忍Bookie服务器的故障. (就HDFS高可用性来说, 使用基于BookKeeper的编辑日志后将不再需要利用NFS来实现共享存储).  

Hedwig是利用BookKeeper实现的一个基于主题的发布-订阅系统. 以ZooKeeper作为基础, Hedwig提供了一个具有高可用性的服务, 即使在订阅者长时间离线的情况下它也能够保证消息的传递.  

BookKeeper是ZooKeeper的一个子项目, 在 http://zookeeper.apache.org/bookkeeper 可以找到它和Hedwig的更多相关用法.  


## 生产环境中的ZooKeeper  

在生产环境中, 应当以复制模式运行ZooKeeper.  

在安放ZooKeeper所用的机器时, 应当考虑尽量减少机器和网络故障可能带来的影响. 一般是跨机架, 电源和交换机来安放服务器. 这样, 这些设备中的任何一个出现故障都不会使集合体损失半数以上的服务器.  

对于那些需要低延迟服务(毫秒级别)的应用来说, 最好将所有的服务器都放在同一个数据中心的同一个集合体中. 也有一些应用不需要低延迟服务, 它们可以通过跨数据中心(每个数据中心至少两台服务器)安防服务器来获得更好的可恢复性, 领导者选举和分布式粗粒度锁是这类应用的代表.  

ZooKeeper中有一个"观察节点"(observer node)概念, 是指没有投票权的跟随者. 由于观察节点不参与写请求过程中达成共识的投票, 因此使用观察节点可以让ZooKeeper集群在不影响写性能的情况下提高读操作的性能. 使用观察节点可以让ZooKeeper集群跨越多个数据中心, 同时不会增加正常投票节点的延迟.  

ZooKeeper是具有高可用性的系统, 对它来说, 最关键的是能够及时地履行其职能. 因此, ZooKeeper应当运行在专用的机器上. 如果有其它应用程序竞争资源, 可能会导致ZooKeeper的性能明显下降.  

通过对ZooKeeper进行配置, 可以使它的事务日志和数据快照分别保存在不同的磁盘驱动器上. 在默认情况下, 两者都保存在dataDir属性所指定的目录中, 但是通过为dataLogDir属性设置一个值, 便可以将事务日志写在指定的位置. 所有的写操作都是通过领导者来完成的, 增加服务器并不能提高写操作的吞吐量, 所以提高性能的关键是写操作的速度.  


ZooKeeper服务器的集合体中, 每个服务器都有一个数值型ID, 服务器ID在集合体中是唯一的, 并且取值范围在1到255之间. 可以通过一个名为myid的纯文本文件设定服务器的ID, 这个文件保存在dataDir参数所设定的目录中.  

还需要将集合体中其他服务器的ID和网络位置告诉所有的服务器. 在ZooKeeper的配置文件中必须为每台服务器添加下面这行配置:  

```  
server.n=hostname:port:port

```  

n是服务器的ID. 这里有2个端口设置: 第一个是跟随者用来连接领导者的端口; 第二个端口被用于领导者选举.  这里有一个包含三台机器的复制模式下ZooKeeper集合体的配置例子:  

```  
tickTime=2000
dataDir=/disk1/zookeeper
dataLogDir=/disk2/zookeeper
clientPoint=2181
initLimit=5
syncLimit=2
server.1=zookeeper1:2888:3888
server.2=zookeeper2:2888:3888
server.3=zookeeper3:2888:3888


```  

服务器在3个端口上监听: 2181端口被用于客户端连接; 对于领导者来说, 2888端口被用于跟随着连接; 3888端口被用于领导者选举阶段的其他服务器连接. 当一个ZooKeeper服务器启动时, 它读取myid文件用于确定自己的服务器ID, 然后通过读取配置文件来确定应当在哪个端口进行监听, 同时确定集合体中其他服务器的网络地址.  

在复制模式下, 有两个额外的强制参数: initLimit和syncLimit, 两者都是以滴答参数的倍数进行度量.  

initLimit参数设定了所有跟随者与领导者进行连接并同步的时间范围. 如果在设定的时间段内, 半数以上的跟随者未能完成同步, 领导者便会宣布放弃领导地位, 然后进行另外一次领导者选举. 如果这种情况经常发生(可以通过日志中的记录发现这种情况), 则表明设定的值太小.  

syncLimit参数设定了允许一个跟随着与领导者进行同步的时间. 如果在设定的时间段内, 一个跟随者未能完成同步, 会自己重启.  

这些是建立和运行一个ZooKeeper服务器集群所需的最少设置. ` <<ZooKeeper管理员指南>> `列出了更多的配置选项, 特别是性能调优方面的.  































  


  


 

 




  


 
 



 


  


















 








 































