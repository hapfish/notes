
web_analysis_and_mining_with_r_cn  
Web Analysis and Mining With R  
**R语言与网站分析**  
李明/著  


个人博客:   www.bassary.com (无法访问)   
QQ邮箱:   568677413@qq.com  


# 第1章  统计思维与网站分析 #

现代统计学的很多理论均是在正态分布的基础上发展起来的. 一旦某一变量服从正态分布, 就可以使用对应的统计学理论来预测该不确定性变量的预测估值及其范围, 并可以给出该预测值的可信度.  

在统计学中除了正态分布以外, 还有很多典型分布. 网站统计分析的基础是: 找到一个服从某种分布(主要是正态分布)的变量, 用以衡量网站绝大部分用户(而非某一特定用户)的整体性能.  

## 统计分析方法 ##

网站分析一般有以下几种基础的思维方法, 也是大多数统计的方法.  
> (1) 细分分析.  网站分析的基础是找出服从正态分布(或其他分布)的变量, 细分分析是最主要的方式.  
> (2) 对比分析.  在细分分析后, 进一步使用对比分析来找到指标变量变化的真实原因.  
> (3) 趋势分析.  主要是研究指标变量的上升下降, 以及周期性等趋势性分析指标的异常变动.  


引流指标包括  浏览量(PV), 访问次数, 访客数(UV), 新访客数, 新访客比率 等等.  
黏性指标涉及  跳出率, 平均访问时长, 平均访问页数 等等.  
产出指标包含了  转化次数, 转化率 两个指标.  


# 第2章  R语言数据操作基础 #

R涉及两个含义, 它即表示一种用于数据分析建模以及绘图的语言. 又指一个有着统计分析功能及强大作图功能的软件系统. R语言是由新西兰奥克兰大学的Ross Ihaka和Robert Gentleman共同创建的. 因为它们把该语言称为R. 该语言在GUN协议 General Public Licence 4免费发行, 现在由"R开发核心团队"负责开发. 由于R语言是由AT&T贝尔实验室所创的S语言发展出的一种语言, 因此, 通常情况下使用S语言编写的代码都可以不做任何修改地在R环境下运行.  

R软件是一个免费的自由软件, 在R的安装程序中只包括8个基础模块. 其他扩展的算法包可以通过CRAN获得. 全球有超过100个CRAN镜像站.  

新用户可以通过 [http://cran.r-project.org/mirrors.html](http://cran.r-project.org/mirrors.html) 浏览CRAN镜像站地址, 包含中国大陆地区的镜像地址.  
这里使用[http://mirror.bjtu.edu.cn/cran/](http://mirror.bjtu.edu.cn/cran/)  

getwd() 命令可以读取工作目录的路径.  
setwd() 命令可以设置工作目录.  
```  
> setwd("C:/MyData/R")
> getwd()
[1] "C:/MyData/R"

> setwd(paste(getwd(),"/demo1",sep=""))
> getwd()
[1] "C:/MyData/R/demo1"


```  

R采用的是UNIX路径规则, 对于Windows系统的用户来说, 如果在路径中使用了Windows常用的"/"作为目录层级间隔符, 则会出错.  

可按上下方向键查看之前输入过的历史命令, 输入命令后, 按Enter键即可显示结果.  

sink() 命令可以将所有后续的输出由终端转向一个外部文件.  
```  
> sink("C:/MyData/R/demo1/demo.txt")
> getwd()
> getwd()
> sink()
> getwd()
[1] "C:/MyData/R/demo1"

```  

source 命令可批量执行命令脚本文件.  
```  
# demo1.r
print("Current workdir is " )
print(getwd())
print("")
print("Finish source command test!!! ")
# print("完成source命令测试")


```  
source命令时, 中文有乱码.  
```  
> source("C:/MyData/R/demo1/demo1.r")
[1] "Current workdir is "
[1] "C:/MyData/R/demo1"
[1] ""
[1] "Finish source command test!!! "
 
```

运行R时, 所有变量, 数据, 函数及结果都是以对象(Object)的形式存在计算机的活动内存中. 此时内存中的所有对象数据称为工作空间数据. 可以用save.image()函数把工作空间数据转存于硬盘中.  
` > save.image("C:/MyData/R/demo1/demo1.RData") `  

一般在处理大数据挖掘项目时, 前期的数据处理最为耗时. 此时通常会把项目中有关数据处理的命令单独制成脚本(可命名为init.data.r). 并在脚本文件最后使用save.image()语句把数据存于硬盘.  
在后续的数据分析脚本(可命名为sol.data.r), 可使用load()命令先载入数据处理脚本产生的对象数据. 这样, 在修整分析脚本时, 就不必再在数据处理阶段耗费时间了.  

&lt;R软件安装目录&gt;/doc/html/index.html 是其帮助文件的存储路径, 可以使用 help.start() 命令打开.  
```  
> help.start()
如果什么都不发生的话，你应该自己打开‘http://127.0.0.1:17185/doc/html/index.html’
```  

## R语言介绍 ##

R是一种解释性语言, 而不是编译语言. 也就是说, 输入的命令能够直接执行.  

R函数都存在一个库(library)中, 该库位于R软件的安装目录 /library 目录下. base包是R语言的核心包, 直接嵌于R软件安装包中, 它包含了数据读写, 操作最基本的函数.  

R对大小写很敏感. 即Z和z的含义是不同的变量名, 同一字母的大写和小写分别代表不同的变量对象. 另外, R对象名称不能以数字开始.  

R工作空间可存储变量和函数对象, 但是对于求值及打印命令, 并不会保存输出结果.  

R语言的注释标识是以井号(#)开始, #后面所跟的都是注释, 直到此行结束为止.  

使用 install.packages() 可以在命令行模式下安装包.  

使用 library() 或者 require() 可以在命令行模式下将已经安装好的包加载至工作空间内.  


从变量声明的角度区分, 数据类型可以分为静态类型和动态类型.  
在编译期间就确定数据类型的语言, 叫静态类型语言. 该类语言要求在使用任一变量之前必须先声明其数据类型. 例如, Java和C就是静态类型语言.  
在运行期间才确定数据类型的语言, 叫动态语言语言. 对于该类语言, 不必事先声明其数据类型, 而是通过第一次的赋值来定义其数据类型. R和Python为动态类型语言.  


从不同数据类型是否可混合使用的角度来区分, 语言又可以分为弱类型语言和强类型语言.  
在弱类型语言中, 不同数据类型间的数据可以混合使用. 例如, VBScript中, 可以将字符串'12'和整数3进行连接, 从而得到字符串'123'.  
在强类型语言中则相反, 不同数据类型间的数据不可以混合使用. 必须通过类型转化函数处理后才可以. R和Python就是强类型语言.  


## R数据类型 ##
R的数据类型有 数值型, 字符型, 复数型 和 逻辑型 .  
**数值(numeric)类型**的取值是实数, 在R环境中使用数字来表示.  
```  
> a<-9.111
> mode(a)
[1] "numeric"

> a<-12345
> mode(a)
[1] "numeric"

```  


**字符(character)类型**的取值是字符串, 在R语言中, 字符串需要使用英文双引号括起来表示.  
```  
> a<-"abcd123"
> mode(a)
[1] "character"

> a<-"Hello World!"
> mode(a)
[1] "character"

```  


**复数(complex)类型**的取值可扩展到虚数, 并使用&lt;实部数值&gt;+i&lt;虚部数值&gt;来表示.  
如果有数平方是负数的话, 那个数就是虚数. 所有的虚数都是复数.  
```  
> a<-100+11i
> mode(a)
[1] "complex"

> a<-10+123i
> mode(a)
[1] "complex"

```  

**逻辑(logical)类型**的取值为TRUE(也可以简写为T)和FALSE(也可以简写为F).  
```  
> a<-T
> mode(a)
[1] "logical"

> a<-FALSE
> mode(a)
[1] "logical"

```  

有两种特殊情况不能使用上述4种数据类型来描述, 数据的缺失和数据的未知状态.  
NA 表示数据集中的某数据缺失.  
NULL 表示未知的状态.  


最能说明NULL和NA区别的是, 当读取向量的长度时.  
NULL不占据任何工作空间, length(c(1,2,3,NULL,4))的返回值为4.  
而NA是占据工作空间的, length(c(1,2,3,NA,4))的返回值是5.  

```  
> length(c(1,2,3,NULL,4))
[1] 4

> length( c( 1, 2, 3, NULL, 4 ) )
[1] 4


> length(c(1,2,3,NA,4))
[1] 5

> length( c( 1, 2, 3, NA, 4) )
[1] 5

```  

有时判断一个数据是否为NA或NULL, 这时可以使用is.na和is.null函数.  
```  
> a<-c( 1, 2, 3, NA, 4, NULL, 5)
> is.na(a)
[1] FALSE FALSE FALSE  TRUE FALSE FALSE
> is.null(a)
[1] FALSE

```  

## 对象及其属性 ##

R语言内部数据变量, 函数结果, 产生的图像等, 都是以对象形式存在的. 不过由于R语言并非编程语言, 并且R语言的用户也非软件专业出身. 所以本书将会弱化函数和图像的对象概念, 更多强调的是数据变量的对象概念.  

R语言给出的常用对象有 向量(vector), 数组(array), 矩阵(matrix), 数据框(data frame), 列表(list) 等. 其中, 数据框和列表的内部元素可以使用不同的数据类型.  
vector是一维的, matrix, list, data frame是二维的, array是多维的.  

对象类型是指R语言组织和管理内部元素的不同方式, 数据类型则描述了一个变量内元素取值的类型.  

**不同对象类型元素取值的数据类型**
<table>
  <tr>
    <th>对象类型</th>  <th>数据类型</th>  <th>是否允许出现不同数据类型</th>
  </tr>
  
  <tr>
    <td>向量</td>  <td>数值型, 复数型, 字符型, 逻辑型</td>  <td>不允许</td>
  </tr>
  <tr>
    <td>因子</td>  <td>数值型, 复数型, 字符型, 逻辑型</td>  <td>不允许</td>
  </tr>
  <tr>
    <td>数组</td>  <td>数值型, 复数型, 字符型, 逻辑型</td>  <td>不允许</td>
  </tr>
  <tr>
    <td>矩阵</td>  <td>数值型, 复数型, 字符型, 逻辑型</td>  <td>不允许</td>
  </tr>
  <tr>
    <td>数据框</td>  <td>数据型, 复数型. 字符型, 逻辑型</td>  <td>相同列内元素, 其数据类型必须相同; 不同列之间的数据类型可以不同</td>
  </tr>
  <tr>
    <td>列表</td>  <td>数据型, 复数型, 字符型, 逻辑型</td>  <td>任何元素的数据类型均可不同</td>
  </tr>
  <tr>
    <td>时间序列</td>  <td>数值型, 复数型, 字符型, 逻辑型</td>  <td>不允许</td>
  </tr>
</table>


R语言使用属性来辅助性描述每个对象信息, 使用mode函数可以读取对象的模式(数据类型), 使用 as.&lt;数据类型&gt; 可以改变对象的模式.  
```  
> a<-"100"
> mode(a)
[1] "character"
> a<-as.numeric(a)
> mode(a)
[1] "numeric"


> a<-"100"
> mode(a)
[1] "character"
> a<-as.complex(a)
> mode(a)
[1] "complex"


> a<-10; b<-0
> mode(a)
[1] "numeric"
> mode(b)
[1] "numeric"
> paste("a=", as.logical(a), "b=", as.logical(b))
[1] "a= TRUE b= FALSE"
> mode(a)
[1] "numeric"



```  

使用length函数获取对象的长度属性. 在R中, 对象长度可以是0, 并可以对超过对象长度的下标赋值. 以增加对象的元素. 赋值后对象的长度会自动增长至此下标处, 而中间未被赋值的元素会被默认赋值为缺失值NA.  
```  
> x<-numeric()
> length(x)
[1] 0
> x[2]<-1
> x[4]<-16
> x
[1] NA  1 NA 16
> length(x)
[1] 4

```  

除了固有属性length和mode外, 要了解其余的属性, 可以使用attributes()和attr()函数来查看, 并且可以对其进行修改.  
attributes()函数读取除长度和模式以外的所有属性, 使用attr(&lt;对象&gt;, "names")读取列名属性. 其返回结果为向量, 并可以直接赋值, 以修改该属性.  
```  
> x<-numeric()
> x[3]<-6
> attributes(x)
NULL



> x<-data.frame(name1=c(1:5), name2=c("c1,","c2","c3","c4","c5"))
> attributes(x)
$names
[1] "name1" "name2"

$row.names
[1] 1 2 3 4 5

$class
[1] "data.frame"

> attr(x, "names")
[1] "name1" "name2"
> attr(x, "row.names")
[1] 1 2 3 4 5


> attr(x, "names")[1]<-"name_a"
> attr(x, "names")
[1] "name_a" "name2" 


```  

一旦某个对象过于庞大, 就往往会影响R软件环境的运行速度. 此时需要查看工作空间内现存的对象列表, 并删除其中的某个对象.  
```  
> ls()
[1] "a" "b" "s" "x"
> rm(a)
> a
错误: 找不到对象'a'


> rm(list=ls())
> ls()
character(0)

```  




## 向量 ##

向量是以一维数组的方式管理数据的一种对象类型, 可以说向量是R语言中最基本的对象类型. 很多算法都是以向量的形式输入的.  

R语言使用 c(&lt;元素1&gt;, &lt;元素2&gt;, ..., &lt;元素n&gt;) 来创建向量, 向量内各元素使用逗号分隔.  
```  
> a1<-c(1, 2, 3, 4)
> mode(a1)
[1] "numeric"

> a2<-c("test1", "test2", "test3", "test4")
> mode(a2)
[1] "character"

> a3<-c(T, F, T, F)
> mode(a3)
[1] "logical"



> a1_2<-c(1, 2, "test1", "test2")
> mode(a1_2)
[1] "character"


> a1_3<-c(1, 2, T, F)
> mode(a1_3)
[1] "numeric"


> a2_3<-c("test1", "test2", T, F)
> mode(a2_3)
[1] "character"



```  

R语言下标索引与其他类型语言的最大区别就是, 下标始于1, 而非0. 可使用**向量对象[下标]** 方式读取该下标的元素, 并且可用 **向量对象[-下标]** 方式读取除该下标元素外的其他元素.  
```  
> a<-c("test1", "test2", "test3", "test4")
> 
> a[1]
[1] "test1"
> a[-1]
[1] "test2" "test3" "test4"


> a[c(1, 3)]
[1] "test1" "test3"
> a[-c(1, 3)]
[1] "test2" "test4"


```  
除了使用一个数据作为下标, 还可以使用一个向量.  


使用which函数可以通过向量内元素的数值, 来得到此元素的向量下标. 如果有多个元素符合筛选要求, 则以向量方式返回多个下标.  
```  
> a<-c("test1", "test2", "test3", "test4")
> a
[1] "test1" "test2" "test3" "test4"


> which(a=="test1")
[1] 1
> which(a=="test3")
[1] 3

> which(a==c("test1", "test2"))
[1] 1 2
> which(a==c("test1", "test3"))
[1] 1
> which(a==c("test1", "test4"))
[1] 1 4

> which(a!="test2")
[1] 1 3 4
> 

```
which比较时, 会延长短向量与长向量一致, 再进行比较.  

对于数值类型的向量, 不仅可以使用等于和不等于方式来返回向量下标, 还可以使用大于或小于等方式返回.  
```  
> a<-c(101, 102, 103, 104)
> a

[1] 101 102 103 104
> which(a>102)
[1] 3 4

> which(a<=103)
[1] 1 2 3

> which(a>102 & a<=103)
[1] 3

> which(a>102 | a<=103)
[1] 1 2 3 4


> which.min(a)
[1] 1
> which(a==min(a))
[1] 1


> which.max(a)
[1] 4
> which(a==max(a))
[1] 4


> a[which(a>102 & a<=103)]
[1] 103

```  

which.max和which.min用于返回数值型向量中最大值和最小值元素的下标.  


subset函数可以方便地索引向量, 矩阵以及函数.  
```  
> a<-c(101, 102, 103, 104)
> subset(a, a > 102 & a <= 103)
[1] 103
# same to a[which(a > 102 & a <= 103)]

```  


match可以称作匹配函数, 形式为  
` match(x, table, nomatch = NA_integer_, incomparables = NULL) `  

<table>
  <tr>
    <th>参数>  <th>说明</th>
  </tr>
  
  <tr>
    <td>X</td>  <td>查询的对象</td> 
  </tr>
  <tr>
    <td>table</td>  <td>匹配的数值, 可以是向量形式</td>
  </tr>
  <tr>
    <td>nomatch</td>  <td>如果不匹配, 返回的数值, 默认返回缺失值NA</td>
  </tr>
  <tr>
    <td>incomparables</td>  <td>设置table参数中无效的匹配值, 默认不设置, 即为NULL<td>
  </tr>
</table>

```  
> a<-c(101, 101, 102, 102, 103, 103, 104, 104, NA, 101, NA, 102)
> a
 [1] 101 101 102 102 103 103 104 104  NA 101  NA 102

 
> match(a, c(101, 103))
 [1]  1  1 NA NA  2  2 NA NA NA  1 NA NA
 
> match(a, c(101, 103), nomatch = 0)
 [1] 1 1 0 0 2 2 0 0 0 1 0 0

 
> match(a, c(101, 103), nomatch = 0, incomparables = 1000)
 [1] 1 1 0 0 2 2 0 0 0 1 0 0
 
> match(a, c(101, 103), nomatch = 0, incomparables = 103)
 [1] 1 1 0 0 0 0 0 0 0 1 0 0
 
> match(a, c(101, 103), nomatch = 0, incomparables = 101)
 [1] 0 0 0 0 2 2 0 0 0 0 0 0
 
 
```  


%in%命令可以判定对象是否包含某项数据, 如果存在则返回T, 如果不存在则返回F.  
```  
> a<-c(101, 101, 102, 103, 104, 104, 103, 102)

> c(101, 105, 106)%in%a
[1]  TRUE FALSE FALSE

> c(103, 105, 101)%in%a
[1]  TRUE FALSE  TRUE


```  

在R语言中, 修改向量内某元素很简单, 只要通过索引找出特定的元素. 然后直接使用 <- 进行赋值即可. R语言还提供了扩展向量和删除元素的功能.  

R可以对对象长度进行任意扩展, 例如, c(&lt;向量1&gt;, &lt;向量2&gt;, ..., &lt;向量n&gt;) 即可将n个向量合并.  
```  
> a<-c(1, 2, 3, 4)
> a
[1] 1 2 3 4


> a<-c(a, c(101, 102, 103))
> a
[1]   1   2   3   4 101 102 103

```  

要删除向量内某一元素, 可使用对向量重新赋值的方式实现. 例如, a[-3]表示向量a中除了第三个元素以外的所有元素. 把它重新赋予a后实现删除a[3]的效果.  
```  
> a<-c(101, 102, 103, 104)
> a
[1] 101 102 103 104

> a<-a[-3]
> a
[1] 101 102 104
> length(a)
[1] 3

```  

R语言可以依据数值的大小使用sort进行排序, 使用rev依据下标进行倒排序. 结合sort和rev使用 rev(sort(&lt;向量&gt;)) , 可以对向量依据大小进行倒排序.  
```  
> a<-c(95, 98, 96, 97, 106, 101, 102, 104, 103)
> a
[1]  95  98  96  97 106 101 102 104 103

> rev(a)
[1] 103 104 102 101 106  97  96  98  95

> sort(a)
[1]  95  96  97  98 101 102 103 104 106

> rev(sort(a))
[1] 106 104 103 102 101  98  97  96  95

> rev(rev(sort(a)))
[1]  95  96  97  98 101 102 103 104 106


```  

希望删除向量内重复的元素, 这时可以使用 unique() 来实现.  
```  
> a<-c(95, 97, 96, 95, 94, 99, 98, 97 ,96)
> a
[1] 95 97 96 95 94 99 98 97 96
> unique(a)
[1] 95 97 96 94 99 98

```  

此功能同样可以使用table函数来实现, 不过比较麻烦.  
```  
> a<-c(95, 97, 96, 95, 94, 99, 98, 97 ,96)
> a
[1] 95 97 96 95 94 99 98 97 96
> as.numeric(names(table(a)))
[1] 94 95 96 97 98 99

```  

实际工作中, 数据集很少是完整的, 许多情况下样本都会包括若干缺失值NA. 这在进行数据分析和挖掘时比较麻烦. R语言通过 na.fail 和 na.omit 函数可以很好地处理样本中的缺失值.  

<table>
  <tr>
    <th>函数</th>  <th>用法</th>  <th>说明</th>
  </tr>

  <tr>
    <td>na.fail</td>  <td>na.fail(&lt;向量a&gt;)</td>  <td>如果向量a内包括至少一个NA, 则返回错误; 如果不包括任何NA, 则返回原有向量. </td>
	
  </tr>
  <tr>
    <td rowspan="2">na.omit</td>  <td>na.omit(&lt;向量a&gt;)</td>  <td>返回删除NA后的向量a</td>
  </tr>
  <tr>
    <td>attr(na.omit(&lt;向量a&gt;), "na.action")</td>  <td>返回向量a中元素为NA的下标</td>
  </tr>
</table>

```  
> a0<-c(95, 99, 97, 93, 96)
> a0
[1] 95 99 97 93 96
> a1<-c(95, 99, 97, NA, 96)
> a1
[1] 95 99 97 NA 96
> a2<-c(95, NA, 97, 93, NA)
> a2
[1] 95 NA 97 93 NA


> na.fail(a0)
[1] 95 99 97 93 96
> na.fail(a1)
Error in na.fail.default(a1) : 对象里有遺漏值
> na.fail(a2)
Error in na.fail.default(a2) : 对象里有遺漏值


> na.omit(a0)
[1] 95 99 97 93 96
> na.omit(a1)
[1] 95 99 97 96
attr(,"na.action")
[1] 4
attr(,"class")
[1] "omit"
> na.omit(a2)
[1] 95 97 93
attr(,"na.action")
[1] 2 5
attr(,"class")
[1] "omit"


> attr(na.omit(a0), "na.action")
NULL
> attr(na.omit(a1), "na.action")
[1] 4
attr(,"class")
[1] "omit"
> attr(na.omit(a2), "na.action")
[1] 2 5
attr(,"class")
[1] "omit"


```  

函数na.fail和na.omit不仅可以应用于向量, 也可以应用于矩阵和数据框. 另外, 还可以使用 !x 方式方便地删除NA.  
```  
> t<-c(95, 99, 97, NA, 101, 106, NA, 104)
> t
[1]  95  99  97  NA 101 106  NA 104

> t[!is.na(t)]
[1]  95  99  97 101 106 104

```  


使用 pmin(&lt;向量1&gt;, &lt;向量2&gt;, ..., &lt;向量n&gt;) 可以依次比较向量1至向量n内的各元素, 并把较小的元素组成新的向量. pmax则是把较大的元素组成新的向量.  
```  
> a<-c(1, 2, 3, 4, 5)
> a
[1] 1 2 3 4 5
> b<-c(1, 3, 5, 7, 9)
> b
[1] 1 3 5 7 9
> c<-c(2, 3, 6, 7, 9)
> c
[1] 2 3 6 7 9
> d<-c(2, 3, 2, 4, 10, 12, 13)
> d
[1]  2  3  2  4 10 12 13


> pmin(a, b, c, d)
[1] 1 2 2 4 5 1 2
Warning message:
In pmin(a, b, c, d) : 参数值将数据略微回收

> pmin(d, a, b, c)
[1] 1 2 2 4 5 1 2
Warning message:
In pmin(d, a, b, c) : 参数值将数据略微回收

> pmax(a, b, c, d)
[1]  2  3  6  7 10 12 13
Warning message:
In pmax(a, b, c, d) : 参数值将数据略微回收

> pmin(a, b, c)
[1] 1 2 3 4 5
> pmax(a, b, c)
[1] 2 3 6 7 9


> intersect(a, b)
[1] 1 3 5
> intersect(b, a)
[1] 1 3 5
> intersect(a, d)
[1] 2 3 4


> union(a, b)
[1] 1 2 3 4 5 7 9
> union(b, a)
[1] 1 3 5 7 9 2 4
> union(a, d)
[1]  1  2  3  4  5 10 12 13


> setdiff(a, b)
[1] 2 4
> setdiff(b, a)
[1] 7 9
> setdiff(a, d)
[1] 1 5


```  
除了比较向量的大小外, 在处理样本间的关系时, 还有一组更常用的操作, 即 取交集, 并集, 补集.  
intersect(&lt;向量1&gt;, &lt;向量2&gt;)  返回由既属于向量1, 也属于向量2的元素(交集)所组成的向量.  
union(&lt;向量1&gt;, &lt;向量2&gt;)  返回由属于向量1或者属于向量2的元素(并集)所组成的向量.  
setdiff(&lt;向量1&gt;, &lt;向量2&gt;)  返回由属于向量1而不属于向量2的元素(补集)所组成的向量.  






## 矩阵和数组 ##

### 矩阵 ###

向量vector用于描述一维数据, 是R语言中最基础的数据结构. 然而在很多情况下. 数据是以二维甚至多维的形式存在的. 利用矩阵matrix可以描述二维数据. 和向量类似, 其内部元素可以是实数, 复数, 字符, 逻辑型数据. 矩阵matrix使用两个下标来访问元素, A[i ,j]表示矩阵第i行, 第j列的元素.  

多维数据array可以描述多维数据. array有一个特征属性叫做维数向量(dim属性), 它的长度是多维数组的维数. dim内的元素则是对应维度的长度. 假设多维数组A表示是一个四维数据, 其中第一维长度是10, 第二维长度是5, 第三维长度是8, 第四维的长度是9, 那么A的维数向量dim(A)是向量c(10, 5, 8, 9). 通过维数向量, 可以很好地描述多维数据.  

在R中, 可以使用matrix函数并以向量形式输入矩阵中的全部元素. 使用ncol和nrow可设置矩阵的行和列数. 从而创建一个矩阵.  
```  
> t<-c(1:10)
> t
 [1]  1  2  3  4  5  6  7  8  9 10
> m<-matrix(t, ncol = 2, nrow = 5)
> m
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10


```  

向量1~10的填充方式为以列为单位填充, 如果想以行为单位填充, 则可以把matrix函数的byrow参数置为T.  
```  
> t<-c(1:10)
> m<-matrix(t, ncol = 2, nrow = 5, byrow = T)
> m
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10

```  

对于matrix函数的行数参数nrow和列数参数ncol, 可以通过dim函数来获取并编辑.  
```  
> t<-c(1:10)
> m<-matrix(t)
> m
      [,1]
 [1,]    1
 [2,]    2
 [3,]    3
 [4,]    4
 [5,]    5
 [6,]    6
 [7,]    7
 [8,]    8
 [9,]    9
[10,]   10
> dim(m)<-c(2,5)
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10

```  

dim(&lt;矩阵&gt;) 是由矩阵的行数和列数这两个元素组成的向量, 称其为维数向量.  

在创建矩阵时, 可以使用dimnames参数设置行和列的名称.  
```  
> t<-c(1:10)
> m<-matrix(t, ncol = 2, nrow = 5, dimnames = list( c("r1", "r2", "r3", "r4", "r5"), c("c1", "c2")))
> m
   c1 c2
r1  1  6
r2  2  7
r3  3  8
r4  4  9
r5  5 10

> dimnames(m)
[[1]]
[1] "r1" "r2" "r3" "r4" "r5"

[[2]]
[1] "c1" "c2"


```  

dimnames参数以list列表形式进行输入.  
可以通过 dimnames(&lt;矩阵&gt;) 来读取并编辑行列名称.  

可以使用 as.vector(&lt;矩阵&gt;) 将矩阵反过来转化为向量.  
```  
> t<-c(1:10)
> m<-matrix(t, ncol = 2, nrow = 5)
> v<-as.vector(m)
> v
 [1]  1  2  3  4  5  6  7  8  9 10

```  

col是列的简称, row是行的简称.  

矩阵是用于管理二维数据的, 所以使用两个下标可以表示矩阵内的元素.  
```  
> t<-c(1:10)
> m<-matrix(t, ncol = 2, nrow = 5, dimnames = list( c("r1", "r2", "r3", "r4", "r5"), c("c1", "c2") ))
> m
   c1 c2
r1  1  6
r2  2  7
r3  3  8
r4  4  9
r5  5 10


> m[3,2]
[1] 8

> m[3, 2]
[1] 8

> m["r3", "c2"]
[1] 8

> m[[8]]
[1] 8

```  

**矩阵索引方式**  

使用行列下标来索引矩阵元素.  
对已经为行和列名称赋值的矩阵, 可以用行和列的名称来代替行列的下标.  
矩阵m实质是由一维向量c(1:10)组成的 ( as.vector(m) 为 c(1:10) ), 而矩阵m第3行第2列的元素实质就是向量c(1:10)的第8个元素, 因此可以用 m[[8]] 来表示相应的元素.  

由于二维矩阵可以看作是多个一维向量以行或列的形式组合起来的. 所以通过矩阵可以很方便地找到矩阵的某行或某列. m[i,] 返回矩阵m第i行的所有元素, 并以向量形式承载.  m[,j] 返回矩阵m第j列的所有元素, 并以向量形式承载.  
```  
> t<-c(1:10)
> m<-matrix(t, ncol = 2, nrow = 5)
> m
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10

> m[1,]
[1] 1 6
> m[, 1]
[1] 1 2 3 4 5

```  

rbind函数可以以行的形式把多个矩阵或向量合并在一起, 扩展成一个新的矩阵.  
```  
> t<-c(1:10)
> m1<-matrix(t, ncol = 2, nrow = 5)
> m1
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10


> m1.1<-rbind(m1, c(21:21))
> m1.1
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10
[6,]   21   21


> t2<-c(101:106)
> m2<-matrix(t2, ncol = 2, nrow = 3)
> m2
     [,1] [,2]
[1,]  101  104
[2,]  102  105
[3,]  103  106

> m1.2<-rbind(m1, m2)
> m1.2
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10
[6,]  101  104
[7,]  102  105
[8,]  103  106


> m1.c1<-cbind(m1, c(201:205))
> m1.c1
     [,1] [,2] [,3]
[1,]    1    6  201
[2,]    2    7  202
[3,]    3    8  203
[4,]    4    9  204
[5,]    5   10  205


```  

使用rbind扩展了矩阵的行, 使用cbind扩展了矩阵的列.  


删除矩阵内某行或某列的方式类似于向量, 实质是对矩阵进行重新赋值, 只要所赋的值不包含欲删除的行或列即可.  
```  

> t<-c(1:20)
> m<-matrix(t, ncol = 4, nrow = 5)
> m
     [,1] [,2] [,3] [,4]
[1,]    1    6   11   16
[2,]    2    7   12   17
[3,]    3    8   13   18
[4,]    4    9   14   19
[5,]    5   10   15   20

# delete a col
> m<-m[,-1]
> m
     [,1] [,2] [,3]
[1,]    6   11   16
[2,]    7   12   17
[3,]    8   13   18
[4,]    9   14   19
[5,]   10   15   20



# delete a row
> m<-m[-1,]
> m
     [,1] [,2] [,3]
[1,]    7   12   17
[2,]    8   13   18
[3,]    9   14   19
[4,]   10   15   20


```  

m[,-1] 表示矩阵m中除第1列外的所有元素, 对m重新赋值后便删除了m的第1列. 同理, m<-m[-1,]删除了第一行.  




### 矩阵的运算 ###

定义样例矩阵  

```  
> A<-matrix(c(1:12), ncol = 3, nrow = 4)
> A
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    2    6   10
[3,]    3    7   11
[4,]    4    8   12


> B<-matrix(c(4:15), ncol = 3, nrow = 4, byrow = T)
> B
     [,1] [,2] [,3]
[1,]    4    5    6
[2,]    7    8    9
[3,]   10   11   12
[4,]   13   14   15



> C<-matrix(c(12:1), ncol = 4, nrow = 3)
> C
     [,1] [,2] [,3] [,4]
[1,]   12    9    6    3
[2,]   11    8    5    2
[3,]   10    7    4    1



> D<-matrix(rnorm(16), 4, 4)
> D
           [,1]       [,2]       [,3]        [,4]
[1,] -1.4795228  0.4962877  1.6760607 -0.06728339
[2,] -0.3573371 -0.6930438 -0.3578681  0.42805317
[3,] -0.2407190  0.5765802  0.8102342 -1.05679668
[4,] -1.6204981 -1.3195070  0.2150811  0.78536755


```  

**一般运算**  

1) 矩阵的加法 (A + B): aij + bij =  (A+B)ij  
```  
> A + B
     [,1] [,2] [,3]
[1,]    5   10   15
[2,]    9   14   19
[3,]   13   18   23
[4,]   17   22   27



```  

矩阵各个元素均与一个常数相加. A + 2  
```  
> A + 2
     [,1] [,2] [,3]
[1,]    3    7   11
[2,]    4    8   12
[3,]    5    9   13
[4,]    6   10   14


```  

2) 矩阵的减法 (A - B):  aij - bij = (A - B)ij
```  
> A - B
     [,1] [,2] [,3]
[1,]   -3    0    3
[2,]   -5   -2    1
[3,]   -7   -4   -1
[4,]   -9   -6   -3


> A - 2
     [,1] [,2] [,3]
[1,]   -1    3    7
[2,]    0    4    8
[3,]    1    5    9
[4,]    2    6   10


```  

3) 矩阵间各个元素分别相乘. aij * bij  

```  
> A * B
     [,1] [,2] [,3]
[1,]    4   25   54
[2,]   14   48   90
[3,]   30   77  132
[4,]   52  112  180



> A * 2
     [,1] [,2] [,3]
[1,]    2   10   18
[2,]    4   12   20
[3,]    6   14   22
[4,]    8   16   24


```  

4) 矩阵相乘AB. (要求A的行数等于B的列数, A的列数等于B的行数)  

```R  
> A %*% C
     [,1] [,2] [,3] [,4]
[1,]  157  112   67   22
[2,]  190  136   82   28
[3,]  223  160   97   34
[4,]  256  184  112   40


```  



**转置矩阵**  

aji = (A的转置矩阵)ij. 在R语言中, 使用t函数可以实现矩阵的转置.  
```  
> t(A)
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4
[2,]    5    6    7    8
[3,]    9   10   11   12

> t(B)
     [,1] [,2] [,3] [,4]
[1,]    4    7   10   13
[2,]    5    8   11   14
[3,]    6    9   12   15


```  

**矩阵求解**  
求解DX=A中的X, 可以使用如下代码, solve函数.  

```  
> solve(D, A)
           [,1]      [,2]       [,3]
[1,] -16.357975 -83.36230 -150.36663
[2,]  10.303631  69.22663  128.14962
[3,] -17.161002 -91.91863 -166.67627
[4,]  -6.648285 -20.33885  -34.02942
> solve(B, A)
Error in solve.default(B, A) : 'a'(4 x 3)必需是正方形的


```  

**矩阵的特征值和特征向量**  

假设A是n阶方阵, 如果存在数值m和非零n维列向量x, 使得 Ax=mx成立. 则称m是A的一个特征值(characteristic value). 非零n维列向量x则成为矩阵A属于(对应于)特征值m的特征向量(characteristic vector).  简称A的特征向量或A. 通过eigen函数可以直接求解方阵D的特征值和特征向量.  
```  
> d.eigen<-eigen(D)

> d.eigen
$values
[1] -0.82115564+0.8138457i -0.82115564-0.8138457i  0.98585329+0.0000000i  0.07949321+0.0000000i

$vectors
                     [,1]                 [,2]          [,3]           [,4]
[1,] 0.6660187+0.0000000i 0.6660187+0.0000000i  0.4320569+0i  0.53632002+0i
[2,] 0.0600660+0.1257823i 0.0600660-0.1257823i -0.3505222+0i -0.52801236+0i
[3,] 0.2647123+0.2992718i 0.2647123-0.2992718i  0.7228682+0i  0.65698131+0i
[4,] 0.5201754+0.3267588i 0.5201754-0.3267588i -0.4097835+0i  0.04403808+0i



> d.eigen$values
[1] -0.82115564+0.8138457i -0.82115564-0.8138457i  0.98585329+0.0000000i  0.07949321+0.0000000i

> d.eigen$vectors
                     [,1]                 [,2]          [,3]           [,4]
[1,] 0.6660187+0.0000000i 0.6660187+0.0000000i  0.4320569+0i  0.53632002+0i
[2,] 0.0600660+0.1257823i 0.0600660-0.1257823i -0.3505222+0i -0.52801236+0i
[3,] 0.2647123+0.2992718i 0.2647123-0.2992718i  0.7228682+0i  0.65698131+0i
[4,] 0.5201754+0.3267588i 0.5201754-0.3267588i -0.4097835+0i  0.04403808+0i



> d.eigen$values[2]
[1] -0.8211556-0.8138457i

> d.eigen$vectors[2]
[1] 0.060066+0.1257823i

> d.eigen$vectors[,2]
[1] 0.6660187+0.0000000i 0.0600660-0.1257823i 0.2647123-0.2992718i 0.5201754-0.3267588i



```  

其中eigen(&lt;方阵&gt;)$values 为方阵的特征值. eigen(&lt;方阵&gt;)$vectors 为方阵的特征向量. 在上例中, 方阵D的特征值有4个, 第i个特征值 d.eigen$values[i] 对应的特征向量为 d.eigen$vectors[,i] .  



### 数组 ###

矩阵可以看成是一个特殊的多维数组(维数为2). 在数组中, 也有维数向量概念. 只是其长度不再只是等于2了. 可使用array函数并设置维数向量来创建一个多维数组.  

```  
> data<-array( c(1:30), dim = c( 2, 5, 3))
> data
, , 1

     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10

, , 2

     [,1] [,2] [,3] [,4] [,5]
[1,]   11   13   15   17   19
[2,]   12   14   16   18   20

, , 3

     [,1] [,2] [,3] [,4] [,5]
[1,]   21   23   25   27   29
[2,]   22   24   26   28   30


> dim(data)
[1] 2 5 3





> ay<-array( c(1:120), dim = c(2, 5, 3, 4))
> ay
, , 1, 1

     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10

, , 2, 1

     [,1] [,2] [,3] [,4] [,5]
[1,]   11   13   15   17   19
[2,]   12   14   16   18   20

, , 3, 1

     [,1] [,2] [,3] [,4] [,5]
[1,]   21   23   25   27   29
[2,]   22   24   26   28   30

, , 1, 2

     [,1] [,2] [,3] [,4] [,5]
[1,]   31   33   35   37   39
[2,]   32   34   36   38   40
# 此处省略后续打印数据

```  

上面表示建立一个三维数据的数组, 其维度是 ` 2 * 5 * 3 ` , 在结果中会依次展示了3个2行5列的矩阵. dim函数同样可以用于多维数组中.  

由于数组是用于描述多维数据的, 所以数组的索引需要用到多个下标.  
data[1, 2, 3]对第三个 ` 2 * 5 ` 矩阵中第1行, 第2列元素(23)进行了索引.  
data[, 3, ]则表示由第二维度下标是3的全部元素组成的二维数据.  
```  
# data<-array( c(1:30), dim = c( 2, 5, 3))

> dim(data)
[1] 2 5 3


> data[1, 2, 3]
[1] 23
> data[, 3, ]
     [,1] [,2] [,3]
[1,]    5   15   25
[2,]    6   16   26

 
> data[, , 3]
     [,1] [,2] [,3] [,4] [,5]
[1,]   21   23   25   27   29
[2,]   22   24   26   28   30


```  

apply函数可以读取多维数组中某个维度的所有数据, 并应用其他函数进行数据处理. apply函数的基本形式为:  
` apply(x, MARGIN, FUN) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>X</td>  <td>多维数组array</td>
  </tr>
  <tr>
    <td>MARGIN</td>  <td>预处理的维数</td>
  </tr>
  <tr>
    <td>FUN</td>  <td>多维数组中某一维度元素的处理函数</td>
  </tr>
</table>


```  
> data<-array( c(1:30), dim = c(2, 5, 3))

> apply(data, 3, sum)[1]
[1] 55
> apply(data, 3, sum)[2]
[1] 155
> apply(data, 3, sum)[3]
[1] 255


> apply(data, 3, sum)
[1]  55 155 255

> sum(data[, , 1])
[1] 55


> apply(data, 1, sum)[1]
[1] 225
> apply(data, 1, sum)[2]
[1] 240
> apply(data, 1, sum)[3]
[1] NA


```  

上例中的data数据是一个三维数据, 其中第三维的下标是1~3, apply(data, 3, sum)[1] 用于计算多维数组data中第三维下标为1的所有元素的总和(fun参数为sum取和函数). 当然, 该功能也可以通过 sum(data[, , 1]) 来实现.



## 列表和数据框 ##

列表list和数据框data.frame也是一个二维数据. 其中向量vector, 多维数组array以及矩阵matrix存储的元素, 其数据类型是唯一的. 列表和数据框内每列元素的数据类型可以不同. 列表内每列的长度也可以不同. 一般, 在使用R语言进行数据分析和挖掘的过程中, 向量和数据框的使用频率是最高的. list则在存储较复杂的数据时作为数据对象.  

### 列表 list ###

list()函数可以用于创建列表对象.  
```  
> l<-list( a = c(1, 2, 3), b = c("one", "two"), c = T, d = c(3i+4, 9i-9))
> l
$a
[1] 1 2 3

$b
[1] "one" "two"

$c
[1] TRUE

$d
[1]  4+3i -9+9i


```  

每列内元素的数据类型可以不同, 而且列名内元素的长度也可以不同. 但是相同列中的元素类型相同. 对于向量索引, 即可以直接使用列下标 &lt;list对象&gt;[[下标]] 的形式. 也可以使用列名称 &lt;list对象&gt;[["列名称"]] 或 &lt;list对象&gt;$列名称 的形式.  
```  
>  l<-list( a = c(1, 2, 3), b = c("one", "two"), c = T, d = c(3i+4, 9i-9))

> l[[1]]
[1] 1 2 3
> l[[2]]
[1] "one" "two"

> l[["a"]]
[1] 1 2 3

> l$A
NULL
> l$a
[1] 1 2 3


```  

列表内的元素不仅可以是不同数据类型的向量或数据, 也可以是一个列表, 即可以使用列表的嵌套来建立更复杂的数据.  
```  
> l1<-list( list("data1", 2, T), c(101:106), c(T, F, F, T))
> l1
[[1]]
[[1]][[1]]
[1] "data1"

[[1]][[2]]
[1] 2

[[1]][[3]]
[1] TRUE


[[2]]
[1] 101 102 103 104 105 106

[[3]]
[1]  TRUE FALSE FALSE  TRUE

> l2<-list(l1, c("new1", "new2", "new3"))
> l2
[[1]]
[[1]][[1]]
[[1]][[1]][[1]]
[1] "data1"

[[1]][[1]][[2]]
[1] 2

[[1]][[1]][[3]]
[1] TRUE


[[1]][[2]]
[1] 101 102 103 104 105 106

[[1]][[3]]
[1]  TRUE FALSE FALSE  TRUE


[[2]]
[1] "new1" "new2" "new3"


```  

这种方式可以把各个不同的数据类型的元素存储于一个list对象中.  

可以使用c( &lt;list对象&gt;, &lt;list对象&gt; ) 合并和扩展list, 注意list( &lt;list对象&gt;, &lt;list对象&gt; )不能进行list合并, 它是实现list的嵌套.  
```  
> l<-list( a = c(1, 2, 3), b = c("one", "two"), c = T, d = c(3i+4, 9i-9))

> l<-c(l, list( e = c(106:101) ))
> l
$a
[1] 1 2 3

$b
[1] "one" "two"

$c
[1] TRUE

$d
[1]  4+3i -9+9i

$e
[1] 106 105 104 103 102 101



```  

unlist函数可以把列表对象转化为向量对象, 转化后元素的数据类型被统一.  
```  
> l<-list( a = c(1, 2, 3), b = c("one", "two"), c = T, d = c(3i+4, 9i-9))

> v1<-unlist(l)
> mode(v1)
[1] "character"


```  




### 数据框 data.frame ###

笔者认为, 数据框是仅次于向量的最重要的数据对象类型. 在R语言中, 很多数据分析算法函数的输入都是数据框对象. 在使用Excel/TXT等格式数据集的函数时, 也是以数据框对象输出的. 类似于list, 数据框也可以由不同的向量作为列来合成. 并且不同列间的元素可以是不同的数据类型. 但是数据框并没有list那么灵活, 数据框内每个列的长度必须相同.  

在实际操作中, 通常会用数据框的一列代表某一变量的所有取值, 用一行代表某一样本数据.  


data.frame函数可以直接把多个向量建立为一个数据框, 并为列设置名称.  
```  
> d_frame<-data.frame(
+   day = c("02-01", "02-02", "02-04", "02-05"),
+   pv = c(1001, 1002, 1004, 1005),
+   uv = c(101, 102, 104, 105),
+   times = c(51, 52, 44, 66) )

> d_frame
    day   pv  uv times
1 02-01 1001 101    51
2 02-02 1002 102    52
3 02-04 1004 104    44
4 02-05 1005 105    66


```  

除了使用向量组成数据框外, 还可以通过data.frame函数把matrix转化为数据框.  
```  
> d_matrix<-matrix(1:12, c(3, 4))
> d_matrix
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

> d_f1<-data.frame(d_matrix)
> d_f1
  X1 X2 X3 X4
1  1  4  7 10
2  2  5  8 11
3  3  6  9 12

```  

可以通过names( &lt;数据框&gt; ) 来读取并编辑列名称.  
```  
> d_matrix<-matrix(1:12, c(3, 4))
> d_f1<-data.frame(d_matrix)

> names(d_f1)
[1] "X1" "X2" "X3" "X4"

> names(d_f1)[1]<-"col1"

> names(d_f1)
[1] "col1" "X2"   "X3"   "X4"


```  

数据框的索引和矩阵类似, 由于都是二维数据, 所以它也有两个维度的下标. 同时数据框的列名称也可以方便地索引数据框的列数据.  
&lt;数据框对象&gt;$列名称  
&lt;数据框对象&gt;[["列名称"]]  
&lt;数据框对象&gt;[[列下标]]  
&lt;数据框对象&gt;[, 列下标]  

```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)
> d_f2
   X1  X2  X3  X4  X5
1 101 105 109 113 117
2 102 106 110 114 118
3 103 107 111 115 119
4 104 108 112 116 120


> d_f2$X1
[1] 101 102 103 104

> d_f2[["X1"]]
[1] 101 102 103 104

> d_f2[[1]]
[1] 101 102 103 104


> d_f2[, 1]
[1] 101 102 103 104


> d_f2[, 1:2]
   X1  X2
1 101 105
2 102 106
3 103 107
4 104 108

> d_f2[, 2:4]
   X2  X3  X4
1 105 109 113
2 106 110 114
3 107 111 115
4 108 112 116


```  

想读取多列的数据, 则可以以 &lt;数据框对象&gt;[, 列下标向量] 方式来获取元素, 并以数据框对象的形式返回. 注意, 不可以采用 &lt;数据框对象&gt;[[列下标向量]] 形式.  

通过 &lt;数据框对象&gt;[行下标, ] , 可以直接获取相应行的所有元素, 并以数据框对象的形式返回.  
```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)

> d_f2[1:3, ]
   X1  X2  X3  X4  X5
1 101 105 109 113 117
2 102 106 110 114 118
3 103 107 111 115 119
> d_f2[2, ]
   X1  X2  X3  X4  X5
2 102 106 110 114 118


> m1<-as.matrix(d_f2)[1:3, ]
> m1
      X1  X2  X3  X4  X5
[1,] 101 105 109 113 117
[2,] 102 106 110 114 118
[3,] 103 107 111 115 119

```  

想要返回向量形式的数据, 则要先把数据框转化为矩阵再进行索引.  

数据框的列索引可以返回一个向量对象, 再继续索引向量进而索引某一元素. 4种方式索引列的某一个元素.  
```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)

> d_f2$X2[1]
[1] 105

> d_f2[["X2"]][1]
[1] 105

> d_f2[[2]][1]
[1] 105

> d_f2[1, 2]
[1] 105

```  

除了索引一个元素, 还可以索引一块元素.  例如:  
```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)


> d_f2[1:4, c(1, 3, 2)]
   X1  X3  X2
1 101 109 105
2 102 110 106
3 103 111 107
4 104 112 108


```  

subset函数可以方便地索引元素, 该函数同样可以应用于数据框中.  
```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)

> subset( d_f2, X2 > 105 & X2 < 110)
   X1  X2  X3  X4  X5
2 102 106 110 114 118
3 103 107 111 115 119
4 104 108 112 116 120

> subset( d_f2, X2 > 105 & X2 < 110, X4)
   X4
2 114
3 115
4 116


```  


使用cbind和rbind函数可以合并扩展矩阵, 它们同样也适用于数据框.  
```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)

# 增加样本数据 (添加一行数据)
> d_f2<-rbind(d-f2, list(1001, 1002, 1003, 1004, 1005))


# 增加数据集新属性 (添加一列数据)
> d_f2<-cbind(d_f2, col = c(2001:2005))

```  


数据框删除操作的实质是对数据框进行重新赋值, 只要所赋值的值内不包含欲删除的行或列的元素即可.  
```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)
> d_f2
   X1  X2  X3  X4  X5
1 101 105 109 113 117
2 102 106 110 114 118
3 103 107 111 115 119
4 104 108 112 116 120

# delete a column
> d_f2<-d_f2[, -1]
> d_f2
   X2  X3  X4  X5
1 105 109 113 117
2 106 110 114 118
3 107 111 115 119
4 108 112 116 120

# delete a row
> d_f2<-d_f2[-1, ]
> d_f2
   X2  X3  X4  X5
2 106 110 114 118
3 107 111 115 119
4 108 112 116 120


```  

na.omit 函数同样适用于数据框的缺失值处理, 使用 na.omit函数可以删除数据框内包括NA相关行数据.  
```  
> df1<-data.frame( a = c(11, 21, NA, 41), b = c(9:12), c = c("v1", "v2", "v3", "v4"))
> df1
   a  b  c
1 11  9 v1
2 21 10 v2
3 NA 11 v3
4 41 12 v4

> na.omit(df1)
   a  b  c
1 11  9 v1
2 21 10 v2
4 41 12 v4


```  
直接删除了包括NA的行数据. 也可以理解为该数据集中, 第3个样本中的a变量数据是NA, 因此直接删除了该样本.  


## 因子 ##


在研究数据时, 一般可以把数据分为分类和数值两种属性.  

<table>
  <tr>
    <th colspan="2">属性类型</th>  <th>描述</th>  <th>例子</th>  <th>R语言描述</th>
  </tr>
  
  <tr>
    <td rowspan="2">分类(定性)</td>  
	<td>标称</td>  <td>标称属性的数值仅是不同的名称, 即标称值只提供区分对象的信息(可以进行等于或不等于比较)</td>  <td>用户ID</td>  <td>无序因子factor</td>
  </tr>
  <tr>
    <td>序数</td>  <td>序数属性的值信息可以确定对象的序(可以进行大于或小于比较)</td>  <td>用户对商品的评分值</td>  <td>有序因子ordered</td>
  </tr>
  
  <tr>
    <td rowspan="2">数值(定量)</td>
	<td>区间</td>  <td>对于区间属性, 值之间的差有意义, 即存在测量单位(可以进行加减)</td>  <td>日期</td>  <td rowspan="2">实数</td>
  </tr>
  <tr>
    <td>比率</td>  <td>比率变量, 差和比率均有意义(可以进行乘除)</td>  <td>页面浏览量</td>  
  </tr>
  
</table>


factor函数可以把向量编码为一个因子.  
` factor(x, levels = sort( unique(x), na.last = TRUE ), labels, exclude = NA, ordered = FALSE) `  

参数说明
<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>x</td>  <td>向量</td>
  </tr>
  <tr>
    <td>levels</td>  <td>是因子的水平, 如果不指定值, 则由向量x内不同的值确定.</td>
  </tr>
  <tr>
    <td>labels</td>  <td>是水平标签, 如果不指定值, 则由向量x内不同的值所对应的字符串确定.</td>
  </tr>
  <tr>
    <td>exclude</td>  <td>在转化时, 如果想把向量内某些取值的元素转化为缺失值NA, 则设置该参数</td>
  </tr>
  <tr>
    <td>ordered</td>  <td>如果取FALSE(默认取值), 则转化后是无序因子; 如果取TRUE, 则转化后是有序因子.</td>
  </tr>
  
</table>


```  
> f1<-factor(c(1:9))
> f1
[1] 1 2 3 4 5 6 7 8 9
Levels: 1 2 3 4 5 6 7 8 9


> f2<-factor(c(1:9), exclude = c(2, 6, 8), ordered = TRUE)
> f2
[1] 1    <NA> 3    4    5    <NA> 7    <NA> 9   
Levels: 1 < 3 < 4 < 5 < 7 < 9


```  




使用as.factor把一个向量转化为无序因子向量.  

```  
> fc<-as.factor( c(101:106) )
> fc
[1] 101 102 103 104 105 106
Levels: 101 102 103 104 105 106

> fc[1] == fc[2]
[1] FALSE

> fc[1] > fc[2]
[1] NA
Warning message:
In Ops.factor(fc[1], fc[2]) : ‘>’ not meaningful for factors


```  

使用as.factor转化的无序因子不能进行大于小于比较, 只能进行等于和不等于比较.  

使用as.ordered转化的有序因子可以进行大于, 小于的比较操作.  
```  
> o1<-as.ordered( c(101:106) )
> o1
[1] 101 102 103 104 105 106
Levels: 101 < 102 < 103 < 104 < 105 < 106

> o<-as.ordered( c("v1", "v2", "v3", "v4", "v5") )
> o
[1] v1 v2 v3 v4 v5
Levels: v1 < v2 < v3 < v4 < v5

> o2<-as.ordered( c("v1", "v2", "v3", "v4", "v5", "v6") )
> o2
[1] v1 v2 v3 v4 v5 v6
Levels: v1 < v2 < v3 < v4 < v5 < v6

> o2[1] == o2[2]
[1] FALSE
> o2[1] > o2[2]
[1] FALSE


```  

is.factor函数用于判断向量是否为无序因子, is.ordered函数用于判断向量是否为有序因子.  
```  
> f1<-as.factor( c(201:206) )
> o1<-as.ordered( c(201:206) )

> is.factor(f1)
[1] TRUE
> is.ordered(f1)
[1] FALSE

> is.factor(o1)
[1] TRUE
> is.ordered(o1)
[1] TRUE

```  

levels(&lt;因子向量&gt;) 以向量的形式读取因子水平对应的字符串, 同时可以直接编辑修改.  
```  
> fc1<-factor( c(201:206) )
> fc1
[1] 201 202 203 204 205 206
Levels: 201 202 203 204 205 206
> levels(fc1)
[1] "201" "202" "203" "204" "205" "206"


> levels(fc1)[1]<-"one"
> fc1
[1] one 202 203 204 205 206
Levels: one 202 203 204 205 206


> levels(fc1)<- c("lv1", "lv2", "lv3", "lv4", "lv5", "lv6")
> fc1
[1] lv1 lv2 lv3 lv4 lv5 lv6
Levels: lv1 lv2 lv3 lv4 lv5 lv6


```  

对于初学者来说, 一个常见的错误就是为某一个因子元素赋予了水平中没有的数值.  

```  
> fc1[1]<-"a"
Warning message:
In `[<-.factor`(`*tmp*`, 1, value = "a") :
  invalid factor level, NA generated

> fc1[1]<-"lv4"
> fc1
[1] lv4 lv2 lv3 lv4 lv5 lv6
Levels: lv1 lv2 lv3 lv4 lv5 lv6

```  


cut函数可以把数值类型, 依据间隔区间分段, 并返回一个因子序列.  
```  
> t<-c(10, 11, 12, 9, 8, 7, 6, 5, 10, 20, 30, 40, 21, 22, 23, 25)

> tc<-cut(t, breaks = c(0, 5, 10, 20, 30))
> tc
 [1] (5,10]  (10,20] (10,20] (5,10]  (5,10]  (5,10]  (5,10]  (0,5]   (5,10]  (10,20] (20,30] <NA>    (20,30] (20,30] (20,30] (20,30]
Levels: (0,5] (5,10] (10,20] (20,30]


> tc[1] <tc[2]
[1] NA
Warning message:
In Ops.factor(tc[1], tc[2]) : ‘<’ not meaningful for factors


> tc1<-cut(t, breaks = c(0, 5, 10, 20, 30), ordered_result = T )
> tc1[1] > tc1[2]
[1] FALSE



```  

cut分割区间返回了无大小意义的因子向量, 在比较两个元素时, 返回了错误提示.  设置 ordered_result参数为T后, 返回的因子向量具有了大小意义.  

通过labels参数, 可以设置返回的因子向量的水平值.  
```  
> t<-c(10, 11, 12, 9, 8, 7, 6, 5, 10, 20, 30, 40, 21, 22, 23, 25)

> tc2
 [1] 2    3    3    2    2    2    2    1    2    3    4    <NA> 4    4    4    4   
Levels: 1 2 3 4

```  



## 字符串 ##

length(&lt;向量&gt;) 可以读取向量内的数目, 但无法读取一个字符串的实际长度. 这时需要用到nchar函数, 通过该函数可以读取字符串内部的字符数目.  
```  
> nchar("value test")
[1] 10
> nchar("8点45分")
[1] 5

```  

paste函数用于合并字符串, 基本形式为 paste(&lt;字符串&gt; ... , sep = "").  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>&lt;字符串&gt; ...</td>  <td>字符串或者字符串对象</td>
  </tr>
  <tr>
    <td>sep</td>  <td>链接多个字符串, 中间的间隔符, 默认为空格.</td>
  </tr>
</table>   

```  
> s1<-paste("今天天气", "晴", "18摄氏度", "微风", sep = "")
> s1
[1] "今天天气晴18摄氏度微风"

> s2<-paste("今天天气", "晴", "18摄氏度", "微风", sep = " -> ")
> s2
[1] "今天天气 -> 晴 -> 18摄氏度 -> 微风"

```  

strsplit函数可依据特定字符串把字符串分割为列表, 其中用于分割的字符串将不再出现.  
```  
> sd<-"今天是: 2016-03-01 时间 12:30:45"
> s1<-strsplit(sd, split = ":")
> s1
[[1]]
[1] "今天是"              " 2016-03-01 时间 12" "30"                  "45"                 


> slist<-unlist(s1)
> slist
[1] "今天是"              " 2016-03-01 时间 12" "30"                  "45"                 
> slist[1]
[1] "今天是"
> slist[2]
[1] " 2016-03-01 时间 12"


```  

笔者通常使用 unlist(strsplit(&lt;字符串&gt;, split = &lt;分割符&gt;)) 函数. 并依据分割符来把一个字符串分割为多个字符串的向量.  


substr函数可以直接读取/替换字符串中的一段子字符串.  
` substr(x, start, stop) `  

substr函数说明.  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>x</td>  <td>字符串或者字符串对象</td>
  </tr>
  <tr>
    <td>start</td>  <td>预读取/替换字符串的第一个下标</td>
  </tr>
  <tr>
    <td>stop</td>  <td>预读取/替换字符串的最后一个下标</td>
  </tr>
</table>


```  
> s1<-"Hello World!"
> s1
[1] "Hello World!"
> substr(s1, 2, 4)
[1] "ell"


> substr("今天是星期一, 天气晴朗", 3 , 6)
[1] "是星期一"


> substr(s1, 2, 4) <-"test"
> s1
[1] "Hteso World!"

> substr(s1, 2, 4) <- "ok?"
> s1
[1] "Hok?o World!"

```  


grep(pattern, x)函数可以在字符型列表(参数x)中找出和特定字符串(参数pattern)匹配的序列编号. 如果不匹配, 返回integer(0), 其长度 length(grep(pattern, x))==0. 其中pattern可以是字符串, 也可以是一个正则表达式.  

```  
> slist<-list("CURL value1.html HTTP/1.0", "Curl value2.htm HTTP/2.0")
> slist
[[1]]
[1] "CURL value1.html HTTP/1.0"

[[2]]
[1] "Curl value2.htm HTTP/2.0"

> g1<-grep(".html", slist)
> g1
[1] 1

> g2<-grep("test", slist)
> g2
integer(0)

> g3<-grep("value", slist)
> g3
[1] 1 2


```  


如果a不是字符型列表, 而是一个字符串, 则grep可用于判别该字符串中是否包含特定的字符串. 如果包含, 则返回1. 不包含则返回integer(0).  
```  
> s1<-"CURL value1.html result 512KB bytes"
> g1<-grep(".html", s1)
> g1
[1] 1

> g2<-grep("test", s1)
> g2
integer(0)

```  


regexpr(pattern, text) 函数可以在字符串x中提取出特定的字符串pattern的相关信息. 其中pattern可以是字符串, 也可以是一个正则表达式.  

```  
> s1<-"curl value1.html return 512kb bytes"

> r1<-regexpr("value", s1)
> r1
[1] 6
attr(,"match.length")
[1] 5
attr(,"useBytes")
[1] TRUE

```  

regexpr() 函数只匹配第一个特定的字符, 想要多次匹配需要使用gregexpr()函数.  

```  
> s1<-"curl value1.html return 512kb bytes, curl value2.html return 1024kb bytes"

> g1<-gregexpr("value", s1)
> g1
[[1]]
[1]  6 43
attr(,"match.length")
[1] 5 5
attr(,"useBytes")
[1] TRUE

```  



chartr() 函数可以直接进行字符的替换, 其查询的规则将以被替换字符串的形式给出.  
` chartr(old, new, x) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>x</td>  <td>字符串或字符串对象</td>
  </tr>
  <tr>
    <td>old</td>  <td>预被替换的x中的旧字符串集合. 如果x字符串中不包括old字符串集合, 则函数仍返回x字符串. 不做任何处理.</td>
  </tr>
  <tr>
    <td>new</td>  <td>替换处理后, 新补充的字符串集合. 长度必须大于等于旧字符串集合.</td>
  </tr>
</table>


```  
> s1<-"Test Hello World!"

> c1<-chartr("va", "kk", s1)
> c1
[1] "Test Hello World!"


> c2<-chartr("lo", "k", s1)
Error in chartr("lo", "k", s1) : 'old'比'new'要长

> c3<-chartr("lo", "ab", s1)
> c3
[1] "Test Heaab Wbrad!"

> c4<-chartr("lo", "abc", s1)
> c4
[1] "Test Heaab Wbrad!"

```  

对应每个字符都替换了, 不是在字符串中截取并替换.  



chartr()替换的单位是字符, sub()或gsub()函数的替换单位则是字符串. sub函数基本形式:  
` sub(pattern, replacement, x) `  


<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>pattern</td>  <td>欲被替代的字符串, 可以使用正则表达式</td>
  </tr>
  <tr>
    <td>replacement</td>  <td>替代后的字符串</td>
  </tr>
  <tr>
    <td>x</td>  <td>原始字符串</td>
  </tr>
  
</table> 


```  
> s1<-"curl value1.html return 512kb bytes, curl value2.html return 1024kb bytes"

> sub1<-sub("value", "数据", s1)
> sub1
[1] "curl 数据1.html return 512kb bytes, curl value2.html return 1024kb bytes"

> sub2<-sub("value", "data", s1)
> sub2
[1] "curl data1.html return 512kb bytes, curl value2.html return 1024kb bytes"


```  

sub函数只对第一个匹配值进行替换, 想要全部替换可以使用gsub函数.  

```  
> s1<-"curl value1.html return 512kb bytes, curl value2.html return 1024kb bytes"

> g1<-gsub("value", "search", s1)
> g1
[1] "curl search1.html return 512kb bytes, curl search2.html return 1024kb bytes"

```  


**正则表达式**  

[] 表示字符集合  

[aeiou]  匹配任何一个英文元音字母  
[0-9]  匹配任意一个数字, 0到9  
[a-z]  匹配任意一个小写英文字母  
[A-Z]  匹配任意一个大写英文字母  
[a-z0-9A-Z_]  匹配任意一个字母, 数字或下划线  

小数点(.)或者逗号(,) 需要使用 `\\` 来取消这些字符的特殊意义.  使用`\\.`来匹配`.`.  


在正则表达式中可以使用限定符来指定数量.  

<table>
  <tr>
    <th>代码/语法</th>  <th>说明</th>	
  </tr>
  
  <tr>
    <td>*</td>  <td>重复0次或更多次</td>
  </tr>
  <tr>
    <td>+</td>  <td>重复一次或更多次</td>
  </tr>
  <tr>
    <td>?</td>  <td>重复0次或1次</td>
  </tr>
  <tr>
    <td>{n}</td>  <td>重复n次</td>
  </tr>
  <tr>
    <td>{n,}</td>  <td>重复n次或更多次</td>
  </tr>
  <tr>
    <td>{n,m}</td>  <td>重复n ~ m次</td>
  </tr>
  
</table>


## 常用数据的创建 ##

使用**gl**函数可以方便地创建一个**因子向量**.  
` gl(n, k, length = n * k, labels = 1:n , ordered = FALSE) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>n</td>  <td>因子水平的数目</td>
  </tr>
  <tr>
    <td>k</td>  <td>重复的次数</td>
  </tr>
  <tr>
    <td>`n * k`</td>  <td>向量长度, 默认`n * k`</td>
  </tr>
  <tr>
    <td>labels</td>  <td>因子水平的标签</td>
  </tr>
  <tr>
    <td>ordered</td>  <td>如果为FALSE(默认), 则因子向量是无序因子. 如果为TRUE, 则因子向量是有序因子.</td>
  </tr>
  
</table>

```  
> gl(3, 4, labels = c("v1", "v2", "v3")) 
 [1] v1 v1 v1 v1 v2 v2 v2 v2 v3 v3 v3 v3
Levels: v1 v2 v3

> gl(3, 2, length = 12, labels = c("v1", "v2", "v3"))
 [1] v1 v1 v2 v2 v3 v3 v1 v1 v2 v2 v3 v3
Levels: v1 v2 v3

```  


**等差数列**产生函数**seq**, 可产生等距间隔的数列.  
` seq(from = 1, to = 1, by = ( (to - from)/(length.out -1))) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>from</td>  <td>等差数列的首项数据, 默认为1</td>
  </tr>
  <tr>
    <td>to</td>  <td>等差数列的尾项数据, 默认为1</td>
  </tr>
  <tr>
    <td>by</td>  <td>等差的数值</td>
  </tr>
  <tr>
    <td>length.out</td>  <td>产生向量的长度</td>
  </tr>
  
</table>


```  
> seq(1, -9)
 [1]  1  0 -1 -2 -3 -4 -5 -6 -7 -8 -9

> seq(1, -9, by = -2)
[1]  1 -1 -3 -5 -7 -9

> seq(1, by = 2, length.out = 10)
 [1]  1  3  5  7  9 11 13 15 17 19

```  

在模拟实际数据情况时, 常常会使用随机抽样函数来从整体中挑出部分样本数据. 随机抽样又分为重复随机抽样和不重复随机抽样两种. 重复抽样是指, 本次从整体抽出的数据样本, 在下一次抽取时同样有机会被抽取. 不重复抽样就是, 一旦被抽取为样本, 下次就不能再被抽取了.  

**sample**函数可以完成**随机抽样**处理.  
` sample(x, size, replace = FALSE) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>x</td>  <td>整体数据, 以向量形式给出</td>
  </tr>
  <tr>
    <td>size</td>  <td>抽取样本的数目</td>
  </tr>
  <tr>
    <td>replace</td>  <td>如果为F(默认值), 则是不重复抽样. 此时size不能大于x的长度. 如果为T, 则是重复抽样, 此时size允许大于x的长度.</td>
  </tr>
</table>


```  
> sample(c(201:220), size = 10)
 [1] 203 216 207 204 217 220 201 212 215 214

> sample(c(201:220), size = 25, replace = T)
 [1] 204 213 213 208 219 216 218 211 220 204 206 206 206 216 208 216 209 212 202 210 216 203 210 212 215

```  


**rep**是**重复序列**函数, 其基本形式是rep(x, n). 其中, x是预重复的序列, 可以是任意数据类型的向量或数值. n是重复的次数.  

```  
> rep(1:9)
[1] 1 2 3 4 5 6 7 8 9
 
> rep(10:15, 4) 
 [1] 10 11 12 13 14 15 10 11 12 13 14 15 10 11 12 13 14 15 10 11 12 13 14 15
 
> rep(c("test1", "test2", "test3"), 3)
[1] "test1" "test2" "test3" "test1" "test2" "test3" "test1" "test2" "test3"
 
> rep(as.factor(c("因子1", "因子2", "因子3")), 3)
[1] 因子1 因子2 因子3 因子1 因子2 因子3 因子1 因子2 因子3
Levels: 因子1 因子2 因子3

```  

对于一个离散型变量X, 可以直接描述X取不同水平的概率值P{X}.  
借用微积分的思想, 可以计算变量X小于等于数值x0时的概率值 P{X<=x0}. 把点(x0, P{X<=x0}}连续化, 进而形成一条曲线, 用函数F(x)来表达该曲线, 它的意义是连续变量X小于等于x时的概率. 我们称该函数F(x)是变量X的分布函数. `F(x) = P{X<=x}`  
对F(x)做微分处理, 可以得到变量X的概率密度函数.  
对F(x)取反函数, 得到分位数函数.  



正态分布有两个参数, 平均值和方差, 其方差的平方根也称为标准差.  

使用` pnorm(x, mean, sd) ` 函数来表达时, 其中的参数x就是连续变量x, 参数mean是平均值, 参数sd是标准差. 其初始默认取值 `mean=0, sd =1 ` .  
概率密度函数使用 ` dnorm(x, mean, sd) ` 函数来表达.  
正态分布随机数的产生函数使用 ` rnorm(n, mean, sd) ` 来表达, 其中n是产生的随机数数目.  

```  
> rnorm(10, 5, 2) 
 [1]  3.8023551  4.1025205  8.0794033  6.2408178  4.6121950  7.0272276 11.2164345  5.0340282  1.8236069  0.7661015

> r1<-rnorm(10, 5, 2) 
> r1
 [1] 5.685253 4.250892 7.123485 4.959627 4.282455 4.854974 2.714526 6.099787 4.221002 6.810436


 
 > pnorm(r1, 5, 2)
 [1] 0.6340604 0.3539960 0.8558237 0.4919473 0.3598826 0.4710969 0.1265739 0.7088037 0.3484535 0.8173250
> pnorm(r1, 5, 1)
 [1] 0.75340801 0.22689598 0.98314338 0.48389779 0.23651890 0.44234526 0.01114252 0.86428744 0.21799034 0.96488587
 
> pnorm(c(1:5), 5, 1)
[1] 3.167124e-05 1.349898e-03 2.275013e-02 1.586553e-01 5.000000e-01
> pnorm(7, 5, 1)
[1] 0.9772499



> dnorm( r1, 5, 2)
 [1] 0.1880999 0.1859586 0.1135248 0.1994305 0.1870378 0.1989474 0.1038290 0.1714820 0.1848999 0.1324175


```  


R语言中其他常用分布函数.  

<table>
  <tr>
    <th>分布</th>  <th>在R中的名称</th>  <th>参数</th>
  </tr>
  
  <tr>
    <td>beta</td>  <td>beta</td>  <td>shape1, shape2, ncp</td>
  </tr>
  <tr>
    <td>binomial</td>  <td>binom</td>  <td>size, prob</td>
  </tr>
  <tr>
    <td>Cauchy</td>  <td>cauchy</td>  <td>location, scale</td>
  </tr>
  <tr>
    <td>chi-squared</td>  <td>shisq</td>  <td>df, ncp</td>
  </tr>
  <tr>
    <td>exponential</td>  <td>exp</td>  <td>rate</td>
  </tr>
  
  <tr>
    <td>F</td>  <td>f</td>  <td>df1, df2, ncp</td>
  </tr>
  <tr>
    <td>gamma</td>  <td>gamma</td>  <td>shape, scale</td>
  </tr>
  <tr>
    <td>geometric</td>  <td>geom</td>  <td>prob</td>
  </tr>
  <tr>
    <td>hypergeometric</td>  <td>hyper</td>  <td>m ,n, k</td>
  </tr>
  <tr>
    <td>log-normal</td>  <td>lnorm</td>  <td>meanlog, sdlog</td>
  </tr>
  
  <tr>
    <td>logistic</td>  <td>logis</td>  <td>location, scale</td>
  </tr>
  <tr>
    <td>negative</td>  <td>binomial</td>  <td>nbinom size, prob</td>
  </tr>
  <tr>
    <td>normal</td>  <td>norm</td>  <td>mean, sd</td>
  </tr>
  <tr>
    <td>Poisson</td>  <td>pois</td>  <td>lambda</td>
  </tr>
  <tr>
    <td>Student'st</td>  <td>t</td>  <td>df, ncp</td>
  </tr>
  
  <tr>
    <td>uniform</td>  <td>unif</td>  <td>min, max</td>
  </tr>
  <tr>
    <td>Weibull</td>  <td>weibull</td>  <td>shape, scale</td>
  </tr>
  <tr>
    <td>Wilcoxon</td>  <td>wilcox</td>  <td>m, n</td>
  </tr>
  
</table>


分布名称前添加前缀后可以代表不同的意义.  
> (1) p&lt;R中的分布名称&gt; 表示该分布的分布函数. 例如, pnorm是正态分布的分布函数.  
> (2) d&lt;R中的分布名称&gt; 表示该分布的概率密度函数, 例如, dnorm是正态分布的概率密度函数.  
> (3) q&lt;R中的分布名称&gt; 表示该分布的分位数函数. 例如, qnorm是正态分布的分位数函数.  
> (4) r&lt;R中的分布名称&gt; 表示该分布的随机序列产生函数. 例如, rnorm是正态分布的随机序列函数.  






## 控制流 ##

R包含所有串行语言都有的基本控制语句, 分支和循环.  

### if else ###

if-else分支  
```  
if(boolean) {
  // do something
} else {
  // do something
}


if(boolean) {
  // do something
} else if(boolean) {
  // do something
} else {
  // do something
}  
  
# demo

> v1<-5
> if ( v1 < 10 ) {
+   v1<-10
+ } else {
+   v1<-100
+ }

> v1
[1] 10



> v1<-5
> if ( v1 < 4 ) { 
+   v1<-1
+ } else if(v1 < 10 & v1 >= 4) {
+   v1<-9
+ } else {
+   v1<-100
+ }
> 
> v1
[1] 9



```  
通过if - else 语句可以组成多个分支判断语句, 如果处理语句中只包含一条语句, 则可以省略大括号{}.  



### switch ###

switch语句可以直接实现多分支语句, 但分支时并无判断的优先级区分.  
` switch(case, case 1 处理, case 2 处理, ..., case n 处理) `  

如果case对象等于n, 则执行第n条分支的case n处理. 如果case的取值大于list对象的长度, 则返回值是null.  
```  
> svalue<-3
> switch(svalue, "value1", "value2", "value3", "value4")
[1] "value3"
> svalue2<-9
> switch(svalue2, "value1", "value2", "value3", "value4")
> 

```  



### for循环 ###

在R语言中, 可以使用for, while以及repeat-break实现循环语句. 循环语句可以简单依据计数操作(当计数器达到了设定的循环次数时自动停止)或者某一向量来进行轮询.  

```  

> d1<-c(1, 1, 2, 3, 5, 7, 9, 11, 2, 4, 6)


> f1<-1
> rs1<-""
> for(i in d1) {
+   rs1[f1]<-as.character(i)
+   f1<-f1 + 1
+ }
> rs1
 [1] "1"  "1"  "2"  "3"  "5"  "7"  "9"  "11" "2"  "4"  "6" 


> f2<-1
> rs2<-""
> for(i in 1:length(d1)) {
+   rs2[f2]<-as.character(d1[i])
+   f2<-f2 + 1
+ }
> 
> rs2
 [1] "1"  "1"  "2"  "3"  "5"  "7"  "9"  "11" "2"  "4"  "6" 

 
 
```  


### while循环 ###

```  
> d1<-c(1, 1, 2, 3, 5, 7, 9, 11, 2, 4, 6)
> i<-1
> wrs1<-""
> while( i < length(d1) ) {
+   wrs1[i]<-as.character(d1[i])
+   i<-i + 1
+ }

> wrs1
 [1] "1"  "1"  "2"  "3"  "5"  "7"  "9"  "11" "2"  "4" 

```  

for实际上是通过遍历一个向量的方式来控制循环次数. while则是直接设置循环的范围. for的应用基本可以覆盖while. 笔者更加倾向于使用for循环语句.  





### repeat break循环 ###

repeat是无限循环语句, 并且会在达到循环条件后使用break语句直接跳出循环.  

```  
> d1<-c(1, 1, 2, 3, 5, 7, 9, 11, 2, 4, 6)
> p1<-1
> prs1<-""
> repeat {
+   if( p1 > length(d1)) {
+     break;
+   } else {
+     prs1[p1]<-as.character(d1[p1])
+   } 
+   p1<-p1 + 1
+ }

> prs1
 [1] "1"  "1"  "2"  "3"  "5"  "7"  "9"  "11" "2"  "4"  "6" 


```  

R语言还提供了next语句, 执行后只会跳出本次循环, 而不会跳出整个循环.  


## 运算符, 函数, 过程 ##

算术运算符  

<table>
  <tr>
    <th>运算符</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td> + </td>  <td>加</td>
  </tr>
  <tr>
    <td> - </td>  <td>减</td>
  </tr>
  <tr>
    <td> * </td>  <td>乘</td>
  </tr>
  <tr>
    <td> / </td>  <td>除</td>
  </tr>
  
  <tr>
    <td> ^ 或 ** </td>  <td>幂运算</td>
  </tr>
  <tr>
    <td> x %% y </td>  <td>求除法运算得到的余数, 如 10 %% 3 结果为1</td>
  </tr>
  <tr>
    <td> x %/% y </td>  <td>整数除法, 例如 10 %/% 3 结果为3 </td>
  </tr>
  
</table>


逻辑运算符  

<table>
  <tr>
    <th>运算符</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td> < </td>  <td>小于</td>
  </tr>
  <tr>
    <td> <= </td>  <td>小于等于</td>
  </tr>
  <tr>
    <td> > </td>  <td>大于</td>
  </tr>
  <tr>
    <td> >= </td>  <td>大于等于</td>
  </tr>
  <tr>
    <td> == </td>  <td>等于</td>
  </tr>
  
  <tr>
    <td> != </td>  <td>不等于</td>
  </tr>
  <tr>
    <td> !x </td>  <td>非x</td>
  </tr>
  <tr>
    <td> x | y </td>  <td>x或y(并集)</td>
  </tr>
  <tr>
    <td> x & y </td>  <td>x和y(交集)</td>
  </tr>
  <tr>
    <td> isTRUE(x) </td>  <td>测试x是否为TRUE</td>
  </tr>
  
</table>


自定义函数的格式如下:  
` func.name<-function(arg_1, arg_2, ...) expression `  

其中func.name为函数的名称, arg_1和arg_2是函数的输入参数. expression是R语言的表达式, 在定义函数时, 可以为某些参数直接设置初始值. 在定义好函数后, 可以使用 func.name(arg_1 = value1, arg_2 = value2, ...)来调用函数. 已经设置好了参数的初始值, 则在调用时可以不为参数设置数值.  

```  
> demo.func<-function( x1, x2 = 0) {
+   if( (x1 + x2) > 100 ) {  
+     rlt = x1 + x2 + 100
+   } else if ( (x1 + x2) >= -90 ) {
+     rlt = x1 + x2
+   } else {
+     rlt <- NA 
+   }
+   rlt
+ }


> demo.func(1, 5)
[1] 6
> demo.func(x1 = 50, x2 = 51)
[1] 201
> demo.func(x1 = -31, x2 = -60)
[1] NA

```  

在函数内部定义的数据对象(包括以参数形式定义的数据对象) 均为局部变量, 因此不会改变函数外部同名对象的数值.  


过程和函数类型, 只是函数内部的对象是局部变量, 而过程内部对象的赋值均是全局性操作. 另外在表现形式上, 过程和函数有很大的区别. 由于过程内部全部是全局变量操作, 所以输入参数和返回值对于过程而言没有任何意义. 即过程无输入参数的概念, 也无返回值的概念. 只有函数才有.  

使用 expression 函数定义一个过程.  

```  
> demo.ex<-expression (
+   if( m > 0 & n > 0 ) {
+     m<- m + n
+     n<-1
+   } else if ( m > 0 & n < 0 ) {
+     m<- m - n
+     n<-2
+   } else if ( m < 0 & n > 0 ) {
+     m<- n - m
+     n<-3
+   } else if ( m < 0 & n < 0 ) {
+     m< - m - n
+     n<-4
+   } else {
+     m<--1
+     n<-0
+   }
+ )
> 
> ls()
[1] "demo.ex"


> eval(demo.ex)
Error in eval(expr, envir, enclos) : 找不到对象'm'


> m<-5
> n<-15
> 
> eval(demo.ex)
> m
[1] 20
> n
[1] 1


```  

 
## 数据的读写操作 ##


read.table 函数可以读取外部数据至一个数据框对象中.  
` read.table(file, header = FALSE, sep = "", encoding = "unknown", ...) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>file</td>  <td>file是一个字符串, 代表读取的数据文件.</td>
  </tr>
  <tr>
    <td>header</td>  <td>如果为FALSE(默认取值), 则不把数据文件的第一行作为列名处理; 如果为TRUE, 则把数据文件的第一行作为列名称处理.</td>
  </tr>
  <tr>
    <td>sep</td>   <td>设置用于区分不同列的分隔符, 默认为空格, 对制表符分隔的文件使用 sep = "\t".</td>
  </tr>
  <tr>
    <td>encoding</td>  <td>编码, 为防止中文乱码, 可以设置 encoding = "UTF-8".</td>
  </tr>
  <tr>
    <td>as.is</td>  <td>用于设置是否把字符类型的列数据(未转化为实数复数和逻辑类型)转化为因子形式, 默认是FALSE, 即全部转化为因子. 如果设置为T, 则所有字符型列数据均不转化为因子. 另外, 还可以设置不需要转化的列序号.</td>
  </tr>
  
  <tr>
    <td>row.names</td>  <td>保存行名的向量, 或文件中一个变量的序号或名称, 缺失时行号取为 1, 2, 3, ...</td>
  </tr>
  <tr>
    <td>col.names</td>  <td>指定列名的字符型向量, 缺失值是 V1, V2, V3, ...</td> 
  </tr>
  <tr>
    <td>na.strings</td>  <td>代表缺失值的处理. (转化为NA)</td>
  </tr>
  <tr>
    <td>nrows</td>  <td>可以读取的最大行数. (忽略负值)</td>
  </tr>
  <tr>
    <td>skip</td>  <td>略过不读取前n行数据</td>
  </tr>
  
  <tr>
    <td>skip.white</td>  <td>在sep已指定的情况下, 如果为TRUE, 则删除字符型变量前后多余的空格.</td>
  </tr>
  <tr>
    <td>blank.lines.skip</td>  <td>如果为TRUE, 则忽略空白行</td>
  </tr>
  
</table>


```  
# demo file
id date time info
1001 2016-03-01 11:33:44 "curl value1.html return 512kb bytes"
1003 2016-03-02 13:34:45 "curl value2.html return false"
1004 2016-03-01 14:45:56 "post a form"


# read file 
> file1<-"c:/MyData/R/demo1/file/read_table.txt"

> read_table1<-read.table(file1, header = TRUE)

> read_table1
    id       date     time                                info
1 1001 2016-03-01 11:33:44 curl value1.html return 512kb bytes
2 1003 2016-03-02 13:34:45       curl value2.html return false
3 1004 2016-03-01 14:45:56                         post a form

> mode(read_table1)
[1] "list"

```  



当文件内的数据是固定宽度时, 可以使用函数 read.fwf 来读取.  
` read.fwf(file, widths, sep = "\t", as.is = FALSE, ...) `  

read.fwf函数的参数与read.table类似, 只是read.fwf函数还有一个特殊的 widths 参数用于设定不同列的宽度.  

```  
# read.fwf demo file
1001 2016-03-01 01:00:00 POST 200
1002 2016-03-01 02:00:00 POST 201
1003 2016-03-02 02:00:00 POST 200



> file2<-"C:/MyData/R/demo1/file/read_fwf.txt"

> read_fwf1<-read.fwf(file2, widths=c(5, 11, 9, 5, 3))

> read_fwf1
    V1          V2        V3    V4  V5
1 1001 2016-03-01  01:00:00  POST  200
2 1002 2016-03-01  02:00:00  POST  201
3 1003 2016-03-02  02:00:00  POST  200

> mode(read_fwf1)
[1] "list"


```  


scan函数读取外部文件时有如下特点:  
> (1) scan函数可以指定输出变量的数据类型.  
> (2) 输出对象的类型更灵活, 可以是数据框, 向量, 矩阵, 列表.  
> (3) 对于很大的数据文件, 使用scan函数时读取速度会更快, 因为它可以事先设定数据类型, 而不是在读取完毕后再检查数据类型的一致性.  

scan参数说明  

<table>
  <tr>
    <td>参数</td>  <td>说明</td>
  </tr>
  
  <tr>
    <td>file</td>  <td>字符串, 文件位置</td>
  </tr>
  <tr>
    <td>what</td>  <td>在读取后, 用于说明各列数据的类型, 可使用logical, integer, numeric, complex, character, raw和list等函数</td>
  </tr>
  <tr>
    <td>sep</td>  <td>分隔符, 默认为空格</td>
  </tr>
  <tr>
    <td>skip</td>  <td>略过不读取前n行数据.</td>
  </tr>
  <tr>
    <td>nlines</td>  <td>要读取的行数</td>
  </tr>
  
  <tr>
    <td>encoding</td>  <td>编码, 防止中文乱码, 可设置 encoding = "UTF-8"</td>
  </tr>
  <tr>
    <td>na.strings</td>  <td>代表缺失数据的值.(转化为NA)</td>
  </tr>
  
</table>


```  
# scan demo file
@a001: 学习R语言 @b002 +1 @c003 分享 

R语言学习教程



 
> file3<-"C:/MyData/R/demo1/file/scan.txt"

> scan_data<-scan(file3, what = "character", sep = "@", encoding = "UTF-8")
Read 7 items

> scan_data
[1] "# scan "          ""                 "a001: 学习R语言 " "b002 +1 "         "c003 分享 "       "R语言学习教程"    " "               

> mode(scan_data)
[1] "character"


```  



CSV(逗号分隔)文件是较为常用的数据文件格式, 通过 read.csv函数可以读取CSV文件并返回一个数据框对象.  


 
```  
# 准备一个CSV文件


> file4<-"C:/MyData/R/demo1/file/read_csv.csv"

> data_csv<-read.csv(file4)

> data_csv
  序列号     日期     时间      反馈
1   1001 2016/3/1 10:22:33      Good
2   1002 2016/3/2 12:34:45      不错
3   1003 2016/3/1  9:05:56 Very Good

> mode(data_csv)
[1] "list"


```  


使用RODBC包可以读取Excel格式文件, 其核心函数分别是odbcConnectExcel和sqlFetch.  

```  
> setwd("C:/MyData/R/demo1")
> getwd()
[1] "C:/MyData/R/demo1"

> .libPaths()
[1] "C:/Program Files/R/R-3.2.4revised/library"

# window 10下, 需要使用管理员身份运行R
> install.packages("RODBC")

> library(RODBC)

> file4<-"C:/MyData/R/demo1/file/read_excel.xls"
> excel_file<-odbcConnectExcel(file4)
> excel_sheet1<-sqlFetch(excel_file, "read_csv")

> excel_sheet1
  序列号       日期                时间      反馈
1   1001 2016-03-01 1899-12-30 10:22:33      Good
2   1002 2016-03-02 1899-12-30 12:34:45      不错
3   1003 2016-03-01 1899-12-30 09:05:56 Very Good
> 
> mode(excel_sheet1)
[1] "list"

# 需要在32位环境下使用 odbcConnectExcel, 只能读取.xls文件, 不能读取.xlsx文件


> excel_file<-odbcConnectExcel(file4)
Error in odbcConnectExcel(file4) : 
  odbcConnectExcel is only usable with 32-bit Windows

  
```  



对于向量和矩阵的输出, 一般使用write函数写入某一文件中.  
` write(x, file, append = FALSE) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>x</td>  <td>数据源, 一般是向量或矩阵类型的数据对象.</td>
  </tr>
  <tr>
    <td>file</td>  <td>输出的文件</td>
  </tr>
  <tr>
    <td>append</td>  <td>如果是FALSE(默认的值), 则清空file文件内的原有数据, 再写入x的内容. 如果是TRUE, 则在file文件原有内容的基础上追加写入x的内容.</td>
  </tr>
  
  
</table>


对于列表或数据框类型对象, 建议使用write.table写入文本文件中, 或者使用write.csv写入csv文件中. 基本参数与write类似.  

```  
> c1<-c(201:210)
> m1<-matrix(1:12, c(3,4))
> df1<-data.frame(m1)


> write(c1, "C:/MyData/R/demo1/output/c1.txt")

> write(m1, "C:/MyData/R/demo1/output/m1.txt")

> write(df1, "C:/MyData/R/demo1/output/df1.txt")
Error in cat(list(...), file, sep, fill, labels, append) : 
  cat目前还不能处理1(种类为'list')参数
  
> write.table(df1, "C:/MyData/R/demo1/output/table_df1.txt")

> write.csv(df1, "C:/MyData/R/demo1/output/csv_df1.txt")

> write.csv(df1, "C:/MyData/R/demo1/output/csv_df1.csv")


```  



cat函数可以把R语言命令输出至一个外部文件, 然后通过source函数运行该批处理文件.  
` cat(..., file = "", sep = "", append = FALSE) `  

其中, ...是预输出的命令, 其他参数可以参考write函数的说明.  







# 第3章  R语言的绘图基础 #

R语言绘图函数分类  

<table>
  <tr>
    <th>分类</th>  <th>描述</th>
  </tr>
  
  <tr>
    <td>绘图窗口操作函数</td>  <td>新建绘图窗口, 设置当前活动窗口</td>
  </tr>
  <tr>
    <td>高级绘图函数</td>  <td>如果 add = FALSE, 则在新窗口中创建一个图形; <br/> 如果 add = TRUE, 则在当前活动窗口中图形叠加在原有的图形之上.</td>
  </tr>
  <tr>
    <td>低级绘图函数</td>  <td>在现有活动窗口添加点, 线, 文字等图形绘图元素, 以及图标, 坐标轴标题, 正标题, 副标题等的提示说明绘图元素.</td>
  </tr>
  <tr>
    <td>扩展绘图包函数</td>  <td>RColorBrewer, lattice, ggplot2 扩展包的核心绘图函数</td>
  </tr>
  
</table>




## 颜色以及文字 点 线的设置 ##
 
各种绘图元素的说明  

<table>
  <tr>
    <th rowspan="2">绘图元素</th>  <th colspan="2">设置方式</th>
  </tr>
  <tr>
    <th>高级绘图函数及其参数</th>  <th>低级绘图函数及其参数</th>
  </tr>
  
  <tr>
    <td>主图形</td>  <td>高级绘图函数且 add = FALSE (默认)</td>  <td>无</td>
  </tr>
  <tr>
    <td>正标题</td>  <td>main参数</td>  <td>title函数的main参数</td>
  </tr>
  <tr>
    <td>副标题</td>  <td>sub参数</td>  <td>title函数的sub参数</td>
  </tr>
  <tr>
    <td>图例</td>  <td>不同函数对应的参数不同</td>  <td>legend函数</td>
  </tr>
  <tr>
    <td>主纵坐标</td>  <td>ylim, axes等参数</td>  <td>asix函数</td>
  </tr>
  
  <tr>
    <td>主纵坐标标题</td>  <td>ylab参数</td>  <td>title的ylab参数</td>
  </tr>
  <tr>
    <td>副纵坐标</td>  <td>无</td>  <td>axis函数</td>
  </tr>
  <tr>
    <td>副纵坐标标题</td>  <td>无</td>  <td>mtext函数</td>
  </tr>
  <tr>
    <td>横坐标</td>  <td>xlim, axes参数</td>  <td>axis参数</td>
  </tr>
  <tr>
    <td>横坐标标题</td>  <td>xlab参数</td>  <td>title函数的xlab参数</td>
  </tr>
  
  <tr>
    <td>图形</td>  <td>高级绘图函数且 add = TRUE</td>  <td>无</td>
  </tr>
  <tr>
    <td>点</td>  <td>无</td>  <td>points函数</td>
  </tr>
  <tr>
    <td>线</td>  <td>可绘制线的高级绘图函数且 add = TRUE</td>  <td>lines(添加曲线)函数 <br/> abline(添加直线)函数 </td>
  </tr>
  <tr>
    <td>文字</td>  <td>无</td>  <td>text函数</td>
  </tr>
    
</table>



文字, 点, 线的常用属性  

<table>
  <tr>
    <th>设置对象</th>  <th>属性</th>  <th>常用英文简写</th>
  </tr>
  
  <tr>
    <td rowspan="3">文字</td>  <td>颜色</td>  <td>col</td>
  </tr>
  <tr>
    <td>文本字体样式</td>  <td>font</td>
  </tr>
  <tr>
    <td>大小(缩放倍数)</td>  <td>cex</td>
  </tr>
  
  <tr>
    <td rowspan="3">点</td>  <td>点的符号</td>  <td>pch</td>
  </tr>
  <tr>
    <td>颜色</td>  <td>col</td>
  </tr>
  <tr>
    <td>大小(缩放倍数)</td>  <td>cex</td>
  </tr>
  
  <tr>
    <td rowspan="3">线</td>  <td>线条宽度</td>  <td>lwd</td>
  </tr>
  <tr>
    <td>线条样式</td>  <td>lty</td>
  </tr>
  <tr>
    <td>颜色</td>  <td>col</td>
  </tr>
  
</table>



R语言提供了自带的固定种类的颜色, 函数是colors(). 该函数可以生成657种颜色名称.  

```  
> plot( c(1:10), type = "b", col = "black")
> text(6, 5, labels = "测试 Hello World!", col = "red")

> points(2, 5, col = "blue")

```  

text函数需要在plot()函数存在时, 才能正常显示.  



展示所有657种颜色名称及其对应的颜色, 并输出到PDF文件中. (window 10 需要管理员身份启动R)  

```  
# save color to pdf

pdf_file="C:/MyData/R/demo1/script/all_color.pdf"
pdf(pdf_file, height = 120)
par(mar = c(0, 10, 3, 0) + 0.1, yaxs = "i")
barplot(
    rep(1, length(colors())), col = rev(colors()),
	names.arg = rev(colors()),
	horiz = TRUE,
	las = 1,
	xaxt = "n",
	main = expression("Bars of colors in" ~ italic(colors()))
	)
	
dev.off()
```  

 
使用rgb函数, 把RGB颜色转化为16进制.  
```  
> plot( c(1:15), type = "b", col = "red")
> color1<-rgb(red = 126, green = 255, blue = 211, max = 255)
> color1
[1] "#7EFFD3"

> text(4, 7, labels = "测试 Hello!", col = color1)

```  


rainbow() 即彩虹的颜色, 是由"赤, 橙, 黄, 绿, 青, 蓝, 紫" 一系列颜色组成的. 函数用法:  
` rainbow(n, s = 1, v = 1, start = 0, end = max(1, n - 1) / n, gamma = 1) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>n</td>  <td>设定产生颜色的数目</td>
  </tr>
  <tr>
    <td>start和end</td>  <td>设定彩虹颜色的一个子集, 生产颜色将从这个子集中选取. 这个子集选取的大致分界线为:<br/>
	                          赤色(red) 为 start = 0, end = 1/6 <br/>
							  黄色(yellow) 为 start = 1/6, end = 2/6 <br/>
							  绿色(green) 为 start = 2/6, end = 3/6 <br/>
							  青色(cyan) 为 start =3/6, end = 4/6 <br/>
							  蓝色(blue) 为 start = 4/6, end = 5/6 <br/>
							  紫色(magenta) 为 start = 5/6. end = 1/6
						</td>	  
  </tr>
</table>



```  
> rainbow(n = 6, start = 0, end = 1/6)
[1] "#FF0000FF" "#FF3300FF" "#FF6600FF" "#FF9900FF" "#FFCC00FF" "#FFFF00FF"
> 
> barplot(rep(1, 6), col = c(rainbow(n = 6, start = 0, end = 1)))



> color_red<-rainbow(n = 6, start = 0, end = 1/6)
> color_yellow<-rainbow(n = 6, start = 1/6, end = 2/6)
> color_green<-rainbow(n = 6, start = 2/6, end = 3/6)
> color_cyan<-rainbow(n = 6, start = 3/6, end = 4/6)
> color_blue<-rainbow(n = 6, start = 4/6, end = 5/6)
> color_magenta<-rainbow(n = 6, start = 5/6, end = 1)

> colors_all<-c(color_red, "white", color_yellow, "white", color_green, "white", color_cyan, "white", color_blue, "white", color_magenta)

> barplot(rep(1:41), col = colors_all)
x.text<-c("赤色", "黄色", "绿色", "青色", "蓝色", "紫色")
> axis(side = 1, at = seq(from = 3, length.out = 6, by = 8.5), labels = x.text, cex = 0.75)

```  


其它的主题配色函数  

<table>
  <tr>
    <th>配色函数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>heat.colors()</td>  <td>从红色渐变到黄色, 再变到白色</td>
  </tr>
  <tr>
    <td>terrain.colors()</td>  <td>从绿色变到黄色, 再到棕色, 最后到白色</td>
  </tr>
  <tr>
    <td>topo.colors()</td>  <td>从蓝色渐变到青色, 再到黄色, 最后到棕色</td>
  </tr>
  <tr>
    <td>cm.colors()</td>  <td>从青色渐变到白色, 再到粉红色</td>
  </tr>
</table>


```  
> barplot( rep(1, 6), col = heat.colors(6) )

> barplot( rep(1, 6), col = terrain.colors(6) )

> barplot( rep(1, 6), col = topo.colors(6) )

> barplot( rep(1, 6), col = cm.colors(6) )

```  

RColorBrewer包提供了3套配色方案, 只需指定配色名称, 就可以用包中的 brewer.pal() 函数生成颜色. 3套配色方案包括:  
> (1) 连续型 Sequential, 生成一系列连续渐变的颜色, 通常用来标记连续型数值的大小.  
> (2) 极端型 Diverging, 生成用深色强调两端, 浅色标示中部的系列颜色, 可以用来标记数据中的离群点.  
> (3) 离散型 Qualitative, 生成一系列彼此差异比较明显的颜色, 通常用来标记分类数据.  


在使用前需要先加载RColorBrewer包.  

```  
> install.packages("RColorBrewer")
--- 在此連線階段时请选用CRAN的鏡子 ---

> library(RColorBrewer)

```  


**seq连续型** 共18组颜色, 每组分为9个渐变颜色.  
```  
> display.brewer.all(type = "seq")

> barplot(rep(1, 6), col = brewer.pal(9, "YlOrRd")[3:8])

```  


**div极端型** 共9组颜色, 每组分为11个渐变颜色展示.  
```  
> display.brewer.all(type = "div")

> barplot( rep(1, 6), col = brewer.pal(11, "BrBG")[3:8])

```  


**qual离散型** 共8组颜色, 每组渐变颜色也不尽相同.  
```  
> display.brewer.all(type = "qual")

> barplot( rep(1, 6), col = brewer.pal(8, "Accent")[3:8])

```  



**文字元素** 可以设置的参数一般包括: 字体(font), 颜色(col), 大小(cex)等.  

font(字体)参数的取值是一个整数, 一般分别用1, 2, 3, 4来表示正常体, 粗体, 斜体和斜粗体.  
```  
> plot( c(0:10), col = "white" )

> text(2, 2, labels = "正常 Hello World!", font = 1)
> text(3, 3, labels = "粗体 Hello World!", font = 2)
> text(4, 4, labels = "斜体 Hello World!", font = 3)
> text(5, 5, labels = "粗斜体 Hello World!", font = 4)

```  


cex(缩放倍数)参数的取值是一个实数, 默认为1, 表示不缩放. 取值小于1时, 表示缩小. 取值大于1时, 表示放大.  
```  
> plot( c(0:10), col = "white", xlim = c(1,12))

> text(2, 2, labels = "0.5倍 Hello World!", cex = 0.5)
> text(3, 3, labels = "0.8倍 Hello World!", cex = 0.8)
> text(4, 4, labels = "1倍 Hello World!", cex = 1)
> text(5, 5, labels = "1.2倍 Hello World!", cex = 1.2)
> text(6, 6, labels = "1.5倍 Hello World!", cex = 1.5)

```  


**点元素** 可以设置的参数一般包括: 点样式(pch), 颜色(col), 大小(缩放倍数cex)等, pch(点样式)参数可取1 ~ 25的数字以及部分符号.  
此外, pch的取值还可以为` * . o O 0 + - | `.  

```  
# point 

plot(1, col = "white", xlim = c(1, 10), ylim = c(1, 10))

for( i in c(0:25) ) {
  x<-(i %% 10) + 1
  y<-(i %/% 10) + 1
  
  
  points(x , y, pch = i, cex = 2)
  text(x - 0.1, y + 0.4, labels = paste(" ", i))
  
}

for( i in (0:25) ) {
if( length(which( c(21:25) == i) >=1 ) ) {
    # set 21 to 25 point't background color
	x<- (i %% 10) + 1
	y<-4
	points(x, y, pch = i, bg = "red", cex = 2)
	text(x - 0.1, y + 0.4, labels = paste("r", i))
	}
}


others<-c("*", ".", "o", "O", "0", "+", "-", "|", "good", "a", "b", "c")
for(i in 1:length(others)) {
  x<- (i %% 10) + 1
  y<- (i %/% 10) + 6
  points(x, y, pch=others[i], cex = 2)
  text(x, y + 0.4, labels = paste("(", others[i], ")"))
}

```  

点样式大小(cex)的设置与文字元素的大小参数设置一致.  


**线元素** 可以设置的参数一般包括: 线条样式(lty), 颜色(col), 粗细(lwd)等.  

线条样式(lty)主要是指实线, 虚线, 点线, 点划线等的样式, lty参数设置不同数值和字符串对应的线条样式:  

<table>
  <tr>
    <th>数值</th>  <th>字符串</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>0</td>  <td>"blank"</td>  <td>不画线</td>
  </tr>
  <tr>
    <td>1</td>  <td>"solid"</td>  <td>实线</td>
  </tr>
  <tr>
    <td>2</td>  <td>"dashed"</td>  <td>虚线</td>
  </tr>
  <tr>
    <td>3</td>  <td>"dotted"</td>  <td>点线</td>
  </tr>
  <tr>
    <td>4</td>  <td>"dotdash"</td>  <td>点划线</td>
  </tr>
  
  <tr>
    <td>5</td>  <td>"longdash"</td>  <td>长划线</td>
  </tr>
  <tr>
    <td>6</td>  <td>"twodash"</td>  <td>点长划线</td>
  </tr>
</table>


```  
# lines lyt

v_num<-c(0:6)
v_str<-c("blank", "solid", "dashed", "dotted", "dotdash", "longdash", "twodash")

point_position<-matrix( rep(rep(1:7), 8), ncol = 8, nrow = 7)

plot(point_position[1, ], type = "l", lty = 0, ylim = c(1, 8), xlim = c(-1, 10), axes = F)
# text(0, 1, labels = "lty=0")

for( i in c(0:6)) {
  lines(point_position[i, ] + 1, lty = i)
  text(0, i + 1, labels = paste("lty=", i))
  
  lines(point_position[i, ] + 1.3, lty = v_str[i + 1])
  text(0, i + 1.3, labels = paste("lty=", v_str[i + 1]))
}  


```  


文字和点有大小的概念, 而线条只有宽度的概念. lwd(宽度)参数默认为1, 表示不缩放. 取值小于1, 表示缩放. 取值大于1, 表示放大.  

```  
# lines lwd

value_lwd<-c(0.5, 0.8, 1, 2, 4)

point_position<-matrix( rep(rep(1:5), 8), ncol = 8, nrow = 5)

plot(point_position[1, ], type = "l", lwd = 0.5, ylim = c(1, 8), xlim = c(-1, 11), axes = F)

for(line in c(1:5)) {
  lines(point_position[line, ], lwd = value_lwd[line])
  text(0, line, labels = paste("lwd=", value_lwd[line]))
}

```  
线条缩小的效果不明显.  





## 低级绘图函数 ##

低级绘图函数主要是在现有活动窗口中添加点, 线, 文字等图形绘图元素. 以及图例, 坐标轴标题, 副标题等提示说明绘图元素.  

因为低级函数必须存在于高级绘图函数的基础上, 所以在使用低级绘图函数前, 要先使用高级绘图函数创建一个图形.  

### 标题 ###

title函数的常用参数  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>  <th>实例</th>
  </tr>
  
  <tr>
    <td>main</td>  <td>设置主标题内容和文字属性</td>  <td>main="主标题"<br/>  main=list("主标题", font = 3, col = "red", cex = 1.5)
  </tr>
  <tr>
    <td>sub</td>  <td>设置副标题内容和文字属性</td>  <td>sub=list("副标题", font = 3, col = "red", cex = 1.2)
  </tr>
  <tr>
    <td>xlab</td>  <td>设置x轴标题内容和文字属性</td>  <td>xlab = list("x轴标题", font = 3, col = "red", cex = 0.8)</td>
  </tr>
  <tr>
    <td>ylab</td>  <td>设置y轴标题内容和文字属性</td>  <td>ylab = list("y轴标题", font = 3, col = "red", cex = 0.8)</td>
  </tr>

</table>


```  
> df1<-data.frame(v1=sample(c(101:110), 6, replace = TRUE), v2=sample(c(101:110), 6, replace = TRUE))
> barplot(as.matrix(rbind(df1$v1, df1$v2)), beside = TRUE, ylim = c(90, 120), col = c("red", "blue"), axes = F)

> main1<-list("趋势分析图", cex = 1.5, col = "red", font = 3)
> sub1<-paste("日期 2016-03-01", "\n", "第三方数据")
> ylab1<-"参与人数"
> xlab1<-"小时"

> barplot(as.matrix(rbind(df1$v1, df1$v2)), beside = TRUE, ylim = c(0, 120), col = c("red", "blue"), axes = F)
> title(main = main1, sub = sub1, ylab = ylab1)


> barplot(as.matrix(rbind(df1$v1, df1$v2)), beside = TRUE, ylim = c(0, 120), col = c("red", "blue"), axes = F)
> title(main = main1, ylab = ylab1, xlab = xlab1)


> barplot(as.matrix(rbind(df1$v1, df1$v2)), beside = TRUE, ylim = c(0, 130), col = c("red", "blue"), main = main1, sub = sub1, ylab = ylab1)
```  

横坐标与副标题可能重复.  

回车字符"\n"可以换行, 在R中, 特殊字符均使用反斜杠"\"开头.  

可以直接在高级绘图函数barplot中设置参数.  


### 图例 ###

图例说明不同颜色代表的数据.  

legend函数的常用参数  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>x 和 y</td>  <td>设置图例的位置(左上角位置). 除了使用 x 和 y 参数外, 还可以使用"bottomright", "bottom", "bottomleft", "left", "topleft", "top", "topright", "right", "center"参数.</td> 
  </tr>
  <tr>
    <td>legend</td>  <td>一个字符向量, 表示图例中的文字</td>
  </tr>
  <tr>
    <td>horiz</td>  <td>为FALSE(默认)时. 图例垂直排列.  为TRUE时, 图例水平排列.</td>
  </tr>
  <tr>
    <td>ncol</td>  <td>图例的列数目, 如果horiz为TRUE, 则此项无意义.</td>
  </tr>
  <tr>
    <td>pch</td>  <td>图例中点的样式, 可以既设置pch, 又设置lty, 并可以设置为NA, 表示某组图例无点样式.</td>
  </tr>
  
  <tr>
    <td>lty</td>  <td>图例中的线样式, 可以既设置pch, 又设置lty, 并可以设置为NA, 表示某组图例无线样式.</td>
  </tr>
  <tr>
    <td>col</td>  <td>图例中点/线的颜色.</td>
  </tr>
  <tr>
    <td>bg</td>  <td>图例的背景颜色, 在bty参数为"n"时无效</td>
  </tr>
  <tr>
    <td>bty</td>  <td>设置图例框的样式, 默认为"o", 表示显示边框. 设置为"n", 表示无边框. </td>
  </tr>
  <tr>
    <td>title</td>  <td>设定图例的标题</td>
  </tr>
  
      
</table>


```  
> name_list<-c("Java语言", "C语言", "R语言", "C++语言")
> colors_all<-c("red", "blue")

> barplot(c(11:20), ylim = c(0, 50))

> legend("topleft", pch = c(15, 15, 16, 16), legend = name_list, col = colors_all, bty = "n", horiz = TRUE)

> legend(1, 25, pch = c(15, 15, NA, NA), legend = name_list, col = colors_all, bty = "o", bg = "yellow")


> barplot(c(11:20), ylim = c(0, 50), legend.text = name_list)

```  

直接在barplot函数设置legend.text参数图标的文字, 系统会直接选取相应的颜色, 线条及点样式. 这种方式较为便捷, 但是灵活性较差, 笔者习惯使用legend函数的设置方法.  



### 坐标轴 ###

坐标轴的设置主要包括主坐标轴(x轴和y轴)的范围和刻度标记, 以及副坐标(右侧的纵坐标)的相关属性.  

axis函数可以在上, 下, 左, 右4个边上设置坐标轴, 并设置坐标轴的范围/刻度标记等.  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>side</td>  <td>设置坐标轴所在的边, 当取值为1, 2, 3, 4时, 分别表示坐标轴处于下, 左, 上, 右各边</td>
  </tr>
  <tr>
    <td>labels</td>  <td>通过向量来设置各坐标轴内各刻度的名称(刻度标记)</td>
  </tr>
  <tr>
    <td>font.axis</td>  <td>刻度标记的字体</td>
  </tr>
  <tr>
    <td>cex.axis</td>  <td>刻度标记的大小</td>
  </tr>
  <tr>
    <td>col.axis</td>  <td>刻度标记的颜色</td>
  </tr>
  
  <tr>
    <td>at</td>  <td>通过向量来设置坐标轴内各刻度标记的位置, at参数向量要与labels向量一一对应</td>
  </tr>
  <tr>
    <td>tick</td>  <td>逻辑参数, 如果tick = TRUE(默认), 则画出坐标轴. 如果tick = FALSE, 则不画出坐标轴. 注意, 此时并不影响刻度标记labels的展示</td>
  </tr>
  <tr>
    <td>col</td>  <td>坐标轴的颜色. tick = TRUE 时有效</td>
  </tr>
  <tr>
    <td>col.ticks</td>  <td>坐标轴刻度的颜色. 注意, col.ticks是指与坐标轴垂直的小刻度线的颜色. col表示设置除刻度标记(labels)以外的部分颜色, 包括 col.ticks</td>
  </tr>
  <tr>
    <td>lty</td>  <td>坐标轴的样式. tick = TRUE时有效</td>
  </tr>
  
  <tr>
    <td>lwd</td>  <td>坐标轴的宽度, tick = TRUE时有效</td>
  </tr>
</table>


```  
> barplot(c(11:20), ylim = c(0, 50), xlim = c(0, 30))

> c1<-seq(from = 2, by = 3, length.out = 7)
> label1<-c("Java", "C", "C++", "R", "Python", "PHP", "Ruby")

> axis(3, c1, labels = label1, cex.axis = 0.75, col.axis = "red", col = "blue", col.ticks = "green")

> axis(side = 1, c1, labels = label1, tick = FALSE, cex.axis = 0.75)

> axis(4, at = c1, labels = c("-60%", "-40%", "-20%", "0", "20%", "40%", "60%"))


```  


在高级绘图函数中, 一般都有用于设置坐标轴的展示和范围的axes, xlim和ylim参数.  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>axes</td>  <td>逻辑参数, 如果 axes = TRUE(默认), 则显示x轴和y轴.  如果 axes = FALSE, 则隐藏x轴和y轴</td>
  </tr>
  <tr>
    <td>xaxt</td>  <td>x轴样式, 取值为"n"表示隐藏x坐标轴. 默认取值是"s", 表示以标准样式显示x轴</td>
  </tr>
  <tr>
    <td>yaxt</td>  <td>y轴样式, 取值同xaxt</td>
  </tr>
  <tr>
    <td>xaxs</td>  <td>x轴的计算方式, 默认为"r", 表示先把原始数据的范围向外扩大4%, 然后用这个范围画坐标轴. 取值为"i"表示直接使用原始数据范围</td>
  </tr>
  <tr>
    <td>yaxs</td>  <td>y轴的计算方式, 取值同xaxs</td>
  </tr>
  
  <tr>
    <td>xlog</td>  <td>设置x轴坐标是否取对数, 默认为FALSE</td>
  </tr>
  <tr>
    <td>ylog</td>  <td>设置y轴坐标是否取对数, 取值同xlog</td>
  </tr>
  <tr>
    <td>xlim</td>  <td>x轴的范围, 设置为c(from, to), from是x轴的首坐标, to是尾坐标</td>
  </tr>
  <tr>
    <td>ylim</td>  <td>y轴的范围, 取值同xlim</td>
  </tr>
</table>


如果要隐藏x轴和y轴, 则设置 axes = FALSE, 如果要隐藏x轴, 只显示y轴, 则设置axes为FALSE后, 并在后续使用axis(2), 也可以直接设置xaxt参数为"n".  
```  
> data_test<-data.frame(v1=sample(c(11:20), 7, replace = TRUE), v2=sample(c(11:20), 7, replace = TRUE))
> data_m<-as.matrix(rbind(data_test$v1, data_test$v2))

> barplot(data_m, beside = TRUE, ylim = c(0, 60), col = c("red", "blue"), axes = F)
> axis(2)

```  




在绘制样本的散点图时, rug函数可以体现相应样本的分布情况.  

```  
> c1<-sample(seq(from = 11, to = 20, by = 0.05), 1000, replace = TRUE)
> c2<-sample(seq(from = 11, to = 20, by = 0.05), 1000, replace = TRUE)

> plot(c1, c2, main = "散点图")
> rug(c1)
> rug(c2, side = 2)


```  

rug(conver)命令绘制转化率数据在x轴的分布情况. 其中黑线越密集, 表示转化率在该区域的分布越集中. rug(c2, side = 2)绘制在y轴的分布情况, side = 2表示绘制位置在y轴上, 默认 side = 1, 表示绘制位置在x轴上.  




### 边框 ###

bty参数可以设置图形边框样式, 取值为字符"o", "l", "7", "c", "u", "]"; 这些字符本身的形状对应边框的样式, 例如o(默认值)表示4条边框都显示, c表示不显示右边框, byt为"n"时, 表示不绘制任何边框.  
如果axes参数设置为FALSE, 则bty参数设置无效.  

```  
> x_name<-c("m1", "m2", "m3", "m4", "m5", "m6")
> v1<-c(sample(c(10:20), 6, replace = TRUE))

> plot(v1, type = "b", ylim = c(0, 60), xaxt = "n", yaxt = "n", main = "bty默认值", xlab = "x轴", ylab = "y轴")

> plot(v1, type = "b", ylim = c(0, 60), xaxt = "n", yaxt = "n", bty = "l", main = "bty=l", xlab = "x轴", ylab = "y轴")

> plot(v1, type = "b", ylim = c(0, 60), xaxt = "n", yaxt = "n", bty = "7", main = "bty=7", xlab = "x轴", ylab = "y轴")

> plot(v1, type = "b", ylim = c(0, 60), xaxt = "n", yaxt = "n", bty = "c", main = "bty=c", xlab = "x轴", ylab = "y轴")

> plot(v1, type = "b", ylim = c(0, 60), xaxt = "n", yaxt = "n", bty = "u", main = "bty=u", xlab = "x轴", ylab = "y轴")

> plot(v1, type = "b", ylim = c(0, 60), xaxt = "n", yaxt = "n", bty = "]", main = "bty=]", xlab = "x轴", ylab = "y轴")

> plot(v1, type = "b", ylim = c(0, 60), xaxt = "n", yaxt = "n", bty = "[", main = "bty=[", xlab = "x轴", ylab = "y轴")
> plot(v1, type = "b", ylim = c(0, 60), xaxt = "n", yaxt = "n", bty = "n", main = "bty=n", xlab = "x轴", ylab = "y轴")

> axis(1, at = 1:6, labels = x_name, tick = FALSE)

> box( bty = "7", col = "blue" , lwd = 1.5, lty = "longdash")

```  

通过box()函数也可以设置各边框的线条样式.  
<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>bty</td>  <td>边框样式</td>
  </tr>
  <tr>
    <td>col</td>  <td>边框颜色</td>
  </tr>
  <tr>
    <td>lwd</td>  <td>边框线条的宽度</td>
  </tr>
  <tr>
    <td>lty</td>  <td>边框线条的样式</td>
  </tr>
</table>
 



### 网格线 ###

grid()函数可以在绘图的基础上添加网格线, 其参数主要包括:  
ny用于设置水平网格的数目, nx用于设置垂直网格的数目.  设置为NA时, 表示不绘制相应的网格线.  
lwd, lty和col参数分别设置网格线的宽度, 样式和颜色.  

```  

> x_name<-c("m1", "m2", "m3", "m4", "m5", "m6")
> v1<-c(sample(c(10:20), 6, replace = TRUE))

> plot(v1, type = "b", ylim = c(0, 60), xaxt = "n", yaxt = "n", main = "bty默认值", xlab = "x轴", ylab = "y轴")
> axis(1, at = 1:6, labels = x_name, tick = FALSE)

> grid(nx = NA, ny = 4, lwd = 1, lty = "dashed", col = "blue")
> grid(nx = 6, ny = 6, lwd = 1, lty = "dashed", col = "red")

```  


### 点 ###

通过低级绘图函数points可以独立添加点元素.  

<table>
  <tr>
    <td>参数</td>  <td>说明</td>
  </tr>
  
  <tr>
    <td>x</td>  <td>横坐标位置, 可以设置向量来代表多个点的位置</td>
  </tr>
  <tr>
    <td>y</td>  <td>纵坐标位置, 可以设置向量来代表多个点的位置</td>
  </tr>
  <tr>
    <td>type</td>  <td>有9种取值, 分别代表不同的样式:<br>
	"p"表示画点(默认);<br/>
	"l"表示画线;<br/>
	"b"表示同时画点和线, 但点线不相交;<br/>
	"c"表示将 type="b"中的点去掉, 只剩下相应的线条部分;<br/>
	"o"表示同时画点和线, 且相互重叠(这是与 type="b" 的区别);<br/>
	"h"表示画铅垂钱;<br/>
	"s"表示画阶梯线, 从一点到下一点时, 先画水平线, 再画垂直线;<br/>
	"S"也是表示画阶梯线, 但从一点到下一点是先画垂直线, 再画水平线;<br/>
	"n"表示不画线</td>	
  </tr>
  <tr>
    <td>pch</td>  <td>点样式</td>
  </tr>
  <tr>
    <td>col</td>  <td>点颜色</td>
  </tr>
  
  <tr>
    <td>bg</td>  <td>点的背景色, pch取21 ~ 25时有效</td>
  </tr>
  <tr>
    <td>lwd</td>  <td>点的边线宽度</td>
  </tr>
  <tr>
    <td>cex</td>  <td>点的大小</td>
  </tr>
</table>


```  
> x1<-c(1:10)
> y1<-c(1:10)

> plot(-5, ylim = c(0, 30), xlim = c(0, 30), col = "blue", main = "ponits type = p")
> points(x1, y1, type = "p")


> plot(-5, ylim = c(0, 30), xlim = c(0, 30), col = "blue", main = "ponits type = l")
> points(x1, y1, type = "l")


> plot(-5, ylim = c(0, 30), xlim = c(0, 30), col = "blue", main = "ponits type = b")
> points(x1, y1, type = "b")


> plot(-5, ylim = c(0, 30), xlim = c(0, 30), col = "blue", main = "ponits type = c")
> points(x1, y1, type = "c")


> plot(-5, ylim = c(0, 30), xlim = c(0, 30), col = "blue", main = "ponits type = o")
> points(x1, y1, type = "o")


> plot(-5, ylim = c(0, 30), xlim = c(0, 30), col = "blue", main = "ponits type = h")
> points(x1, y1, type = "h")


> plot(-5, ylim = c(0, 30), xlim = c(0, 30), col = "blue", main = "ponits type = s")
> points(x1, y1, type = "s")


> plot(-5, ylim = c(0, 30), xlim = c(0, 30), col = "blue", main = "ponits type = S")
> points(x1, y1, type = "S")


> plot(-5, ylim = c(0, 30), xlim = c(0, 30), col = "blue", main = "ponits type = n")
> points(x1, y1, type = "n")


```  



### 线 ###

使用函数来绘制曲线(lines函数), 直线(abline函数), 线段(segments函数).  

abline函数的基本形式是:  
` abline(a = NULL, b = NULL, h = NULL, v = NULL, coef = NULL) `  

a是截距, b是斜率, h是画水平线时的纵轴值, v是画垂直线时的横轴值. coef是一个能用函数coef()提取系数(包括斜率和截距)的R对象, 典型的使用案例就是用线性模型(回归)生成的对象. 其系数是一个长度为2的向量, 并分别表示为直线的截距和斜率.  

<table>
  <tr>
    <th>类型</th>  <th>形式</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>直线</td>  <td>abline(a, b)</td>  <td>画出 y = a + bx直线</td>
  </tr>
  <tr>
    <td>水平线</td>  <td>abline(h = y)</td>  <td>画出一条由所有纵坐标等于y值的点所组成的水平直线</td>
  </tr>
  <tr>
    <td>垂直线</td>  <td>abline(v = x)</td>  <td>画出一条由所有横坐标等于x值的点所组成的垂直直线</td>
  </tr>
  <tr>
    <td>线性模型回归直线</td>  <td>abline(lm.obj)</td>  <td>画出由lm函数获取的回归直线的模型</td>
  </tr>
</table>


```  
> plot(-5, ylim = c(0, 30), xlim = c(0, 30))
> abline(5, 2)
> abline(5, 3)
> 
> abline(h = 10)
> abline(h = 12)
> 
> abline(v = 20)
> abline(v = 21)



> v1<-sample(seq(from = 5, to = 20, by =1), 10, replace = TRUE) 
> v2<-sample(seq(from = 4, to = 21, by = 1), 10, replace = TRUE)
> lm_data<-lm(v1 ~ v2)
> lm_data

Call:
lm(formula = v1 ~ v2)

Coefficients:
(Intercept)           v2  
      4.068        0.902  

	  
> plot(v1 ~ v2, ylab = "v1数据", xlab = "v2数据", ylim = c(0, 30), xlim = c(0, 30))
> abline(lm_data)


```  

lm是回归模型函数, lm(v1 ~ v2)表示最后得出的模型是一个线性模型.  

abline函数还有col, lty, lwd等关于线元素的参数.  


和abline不同, segments函数只绘制一段直线. 而并非绘制贯穿整个绘图窗口的直线. 在` segments(x0, y0, x1 = x0, y1 =y0, ...) `中, 主要的4个参数代表线段的起点和终点坐标. 此外还有col, lty, lwd等关于线元素的参数.  

```  
> plot(-5, ylim = c(0, 30), xlim = c(0, 30), main = "segments测试")

> segments(2, 3, 7, 8, col = "blue", lty = "dotdash", lwd = 1.5)
> segments(5, 10, 20, 30, col = "red", lty = "twodash", lwd = 1)


```  


arrows函数与segments函数很类似, 只是多了一个angle参数用于设置箭头样式, 它表示箭头尖短线的角度. (默认为30度)  

```  
> plot(-5, ylim = c(0, 30), xlim = c(0, 30), col ="blue", main = "arrows测试")

> arrows(1, 2, 25, 5, angle = 90)
> text(27, 5, "angle=90")

> arrows(1, 7, 25, 10, angle = 60)
> text(27, 10, "angle=60")


> arrows(1, 12, 25, 15, angle = 30)
> text(27, 15, "angle=30")


> arrows(1, 17, 25, 20, angle = 0)
> text(27, 20, "angle=0")

```  

abline, segments和arrows只能绘制直线, lines可以通过散点样本的坐标绘制任意曲线. plot是绘制散点图的高级绘图函数, 但是它并没有add参数, 即在同一绘图窗口不能使用两个plot函数, 此时可以使用lines函数.  

在` lines(x, y = NULL, type = "l", ...) `中, x和y分别是散点样本的x轴与y轴坐标数据. type参数可以参考points函数, 支持col, lty, lwd等关于线元素的参数.  

```  
> plot(-5, ylim = c(0, 30), xlim = c(0, 30), main = "lines测试")

> px1<-seq(from = 5, by = 2, length.out = 10)
> py1<-sample(c(10:25), 10, replace = TRUE)
> lines(px1, py1, type = "b", col = "red")

> px2<-seq(from = 5, by =2, length.out = 10)
> py2<-sample(c(5:30), 10, replace = TRUE)
> lines(px2, py2, type = "o", col = "blue")



```  


### 文字 ###

text函数用于添加文字, ` text(x, y = NULL, labels = seq_along(x), cex = 1, col = NULL, font = NUll, ...) `  
x和y表示绘制文字的位置向量, labels用于设置文字内容; cex, col和font参数分别表示文字大小, 颜色和字体.  

```  
> plot(-5, ylim = c(0, 30), xlim = c(0, 30), main = "text函数")

> text(5, 10, col = "blue")
> text(10, 15, labels = "Hello World!", cex = 1.5, col = "red", font = 3)
> text(20, 25, labels = "Hello World!", cex = 1, col = "red", font = 3)

> text(c(10:15), c(5:10), labels = "Hello World!", cex = 1, col = "red", font = 3)

```  


### 多边形 ###

polygon函数用于绘制一个多边形, 基本形式为:  
` polygon(x, y, ...) `  

其中x向量和y向量用于设置多边形各个顶点的坐标位置.  

```  

> plot(-5, ylim = c(0, 30), xlim = c(0, 30), main = "多边形1")
> polygon(x = c(2, 18, 18, 2), y = c(3, 3, 15, 15), col = "blue", border = "red")


> plot(-5, ylim = c(0, 30), xlim = c(0, 30), main = "多边形2")
> polygon(x = c(2, 18, 2, 18), y = c(3, 3, 15, 15), col = "yellow", border = "blue")


> plot(-5, ylim = c(0, 30), xlim = c(0, 30), main = "多边形-梯形")
> polygon(x = c(2, 22, 14, 4), y = c(5, 5, 10, 10))


```  

注意, 两个多边形的顶点坐标值相同, 但是顶点的绘制顺序不同, 这最终也会导致绘制的多边形不同.  





## 高级绘图函数应用 ##

高级绘图函数是R语言的主体, 大部分高级绘图函数均有add参数(plot没有). 如果 add = FALSE(默认), 则在新窗口创建图形. 如果 add = TRUE 则在当前活动窗口中的原有图形之上叠加. 在基础包中, 常用的高级函数有 plot(绘制散点图/曲线图), barplot(绘制柱形图/条形图), hist(绘制直方图), pie(绘制饼图)等. 此外使用ggplots扩展包可以绘制星状图, 堆积面积图, 气泡图.  

常用图形  
<table>
  <tr>
    <th>类型</th>  <th>说明</th>  <th>R函数</th>
  </tr>
  
  <tr>
    <td>散点图</td>  <td>把一维数据或二维数据描述在x-y平面上</td>  <td>plot</td>
  </tr>
  <tr>
    <td>气泡图</td>  <td>在散点图的基础上, 使用点的大小来代表第三维数据</td>  <td>plot或ggplot2包ggplot函数</td>
  </tr>
  <tr>
    <td>曲线图</td>  <td>把散点图的所有样本点连接成线来展示</td>  <td>plot或lines</td>
  </tr>
  <tr>
    <td>柱形图</td>  <td>把主体数据通过垂直于x轴的柱形来展示</td>  <td>barplot</td>
  </tr>
  <tr>
    <td>条形图</td>  <td>柱形图翻转90度</td>  <td>barplot</td>
  </tr>
  
  <tr>
    <td>饼图</td>  <td>静态展示各个成分占整体的情况</td>  <td>pie</td>
  </tr>
  <tr>
    <td>堆积面积图</td>  <td>动态展示各个成分占整体的情况</td>  <td>ggplot2包 qplot函数</td>
  </tr>
  <tr>
    <td>直方图</td>  <td>分析一维数据的频次, 分隔尺度是有限数据</td>  <td>hist</td>
  </tr>
  <tr>
    <td>密度曲线图</td>  <td>分析一维数据的频次, 分隔尺度是无限小</td>  <td>plot(density())</td>
  </tr>
  <tr>
    <td>雷达图/星状图</td>  <td>展示样本点的不同维度取值</td>  <td>fms包的radarchart函数</td>
  </tr>
  
  <tr>
    <td>关系网络图</td>  <td>绘制不同样本点之间的联系程度</td>  <td>igraph包 plot函数</td>
  </tr>
</table>



本章将在国外专家Andrew Abela整理分析的基础上结合互联网常用分析方式, 从比较, 分布, 构成, 联系等4个大的方面入手, 给出相应的图形选择思路.  
> (1) 比较: 可以比较相同变量在不同时间下的数据, 即所谓的时间序列分析和预测. 同时可以比较相同变量不同分类下的数据.  
> (2) 分布: 在分析变量前, 往往要查看样本点的分布是否符合正态分布, 以及是否有异常点等.  
> (3) 联系: 可以绘制散点图或气泡图, 用以分析二维或三维数据间的关系. 使用网络关系图可以查看不同样本间的联系.  
> (4) 构成: 可以静态比较各个成分占总体的比例, 从而分清问题的主次. 也可以动态查看不同成分的比例变化.  



### 散点图 ###

plot默认绘制散点图.  

```  
> x1<-sample(seq(from = 5, by = 0.1, length.out = 100), 100, replace = TRUE)
> y1<-sample(seq(from = 10, by = 1, length.out = 1000), 100, replace = TRUE)
 
> plot(x1, y1, ylim = c(0, 1100), xlim = c(0, 25), main = "散点图", xlab = "x1数据", ylab = "y1数据")

> rug(x1)
> rug(y1, side = 2)

```  


### 气泡图 ###

plot函数设置cex表示气泡大小, 可以绘制气泡图.  

```  
> library(RColorBrewer)
> col_type<-brewer.pal(11, "Spectral")[2:11]

> x1<-sample(seq(from = 5, by = 1, length.out = 20), 10, replace = TRUE)
> y1<-sample(seq(from = 10, by = 5, length.out = 30), 10, replace = TRUE)
> z1<-sample(seq(from = 100, by = 10, length.out = 15), 10, replace = TRUE)
> title1<-paste("type", seq(from = 1, by = 3, length.out = 10))

> cex_max<-15
> cex_min<-5
> cex_rate<-(cex_max - cex_min) / (max(z1) - min(z1))
> cex_displacement<-cex_min - cex_rate * min(z1) 
> cex_value<-cex_displacement + cex_rate * z1

> cex_value
 [1]  7.307692 15.000000 11.923077  9.615385 13.461538  8.076923  8.076923
 [8] 15.000000  5.000000 12.692308
 

> plot(x1, y1, col = col_type, cex = cex_value, pch = 16, ylim = c(0, 200), xlim = c(0, 35), xlab = "x1数据", ylab = "y1数据", main = list("气泡图", cex = 3), yaxt = "n")

> legend("topleft", legend = title1, pch = 16, col = col_type, bty = "n", cex = 1.2, ncol = 5)

> axis(2, labels = paste("y=", seq(from = 0, by = 50, length.out = 5)), at = seq(from = 0, by = 50, length.out = 5))

> text(x = 25, y = 160, labels = "z1数据用气泡大小表示", cex = 1.5)


```  


### 曲线图 ###

设置plot函数的type参数把样本的散点串联起来变成曲线, 在绘制曲线图时, type参数可以设置为如下方面:  
> (1) "l"  表示画线.  
> (2) "b"  表示同时画点和线, 但点线不相交.  
> (3) "c"  表示将 type = "b" 中的点去掉, 只剩下相应的线条部分.  
> (4) "o"  表示同时画点和线, 且相互重叠(这是与type = "b"的区别).  
> (5) "s"  表示画阶梯线, 从一点到下一点时, 先画水平线, 再画垂直线.  
> (6) "S"  也是画阶梯线, 但从下一点是先画垂直线, 再画水平线.  


```  
> x_value<-paste("v", seq(from = 1, by = 1, length.out = 10), seq = "")

> y1<-sample(seq(from = 5, by = 2, length.out = 20), 10, replace = TRUE)
> y2<-sample(seq(from = 10, by = 1, length.out = 25), 10, replace = TRUE)
> y3<-sample(seq(from = 5, by = 1, length.out = 30), 10, replace = TRUE)

> y_name<-paste("y", seq(from = 1, by = 1, length.out = 3))
> col_value<-c("red", "blue", "yellow")



> plot(y1, type = "b", xaxt = "n", ylim = c(0, 100), col = col_value[1], main = "曲线图", xlab = "x数据", ylab = "y数据")

> axis(1, at = 1:10, labels = x_value, tick = FALSE)
> legend("topleft", legend = y_name, horiz = T, pch = 15, col = col_value, cex = 1.2, bty = "n")
> grid(nx = NA, ny = 6, lwd = 1, lty = 2, col = "green")

> lines(y2, type = "o", col = col_value[2])
> lines(y3, type = "c", col = col_value[3])


```  



### 柱状图 ###

柱状图实际还是散点图, 只是它更适合用户描述主数据(y轴数据)在不同分类(x轴是因子类型的分类数据, 或者是时间数据)下的展示情况. 同时, 柱状图还可以清晰地绘制不同情况下的多组数据, 以便横向对比. 基本形式是:  
` barplot(height, horiz = FALSE, beside = FALSE, ...) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>height</td>  <td>绘制的数据. 如果绘制一组数据, 则以向量形式输入. 如果绘制多组数据, 则以矩阵形式输入, 每行表示一组数据</td>
  </tr>
  <tr>
    <td>horiz</td>  <td>如果是FALSE(默认取值), 则绘制柱状图. 如果是TRUE, 则绘制条形图</td>
  </tr>
  <tr>
    <td>beside</td>  <td>如果是FALSE(默认值), 则不同组数据垂直堆积表示. 如果是TRUE, 则不同组数据水平并列展示</td>
  </tr>
</table>


```  
> y1<-sample(seq(from = 1, by = 1, length.out = 20), 6, replace =TRUE)
> y2<-sample(seq(from = 1, by = 1, length.out = 20), 6, replace =TRUE)

> col_value<-c("red", "blue")
> y_frame<-data.frame(y1_value = y1, y2_value = y2)

> barplot(y_frame$y1_value, beside = TRUE, axes = F)
> axis(2)
> x_name<-paste("x名", seq(from = 1, by = 1, length.out = 6))
> axis(1, seq(from = 1, by = 2, length.out = 6), labels = x_name, tick = FALSE, cex.axis = 1.2)


> barplot(t(as.matrix(y_frame)), beside = TRUE, col = col_value, axes = F)
> axis(2)
> axis(1, seq(from = 2, by = 3, length.out = 6), labels = x_name, tick = FALSE, cex.axis = 1.1)
> title(main = "柱状图", cex = 1.8, col = "green", font = 4, ylab = "y的数据")


# horiz = true
> barplot(t(as.matrix(y_frame)), beside = TRUE, col = col_value, axes = F, horiz = T)
> axis(1)
> axis(2, seq(from = 2, by = 3, length.out = 6), labels = x_name, tick = FALSE, cex.axis = 1.1)
> title( main = list("柱状图horiz=TRUE时为条形图", cex = 1.8, col = "green", font = 3), xlab = "y数据")


# beside = false
> barplot(t(as.matrix(y_frame)), col = col_value, axes = F)
> axis(2)
> axis(1, seq(from = 1, by = 1, length.out = 6), labels = x_name, tick = FALSE, cex.axis = 1.2)
> title(main = list("beside默认值", cex = 1.2, col = "red", font = 3), ylab = "y数据")

```  

设置horiz为TRUE, 则绘制平行于x轴的条形图.  

当有多组数据时, 可通过beside参数把各组数据以水平并列的方式(beside = TRUE)展示, 或以垂直堆积方式(beside = FALSE, 默认值)展示.  




### 条形图 ###

把barplot函数中horiz参数设置为TRUE便可绘制条形图.  




### 饼图 ###

饼图可以静态展示整体内不同成分的构成, 实际上饼图也可以使用条形图或柱状图代替, 当成分数目较少时, 使用饼图绘制更好. 当成分数目较多时, 可以考虑使用柱状图或条形图.  

饼图的核心函数是:  
` pie(x, labels = names(x), ... `  

```  
> data_name<-paste("data", seq(from = 1, by = 1, length.out = 7), sep = "")
> data_value<-sample(seq(from = 10, by = 1, length.out = 50), 7, replace = TRUE)

> pie_data<-data.frame(name = data_name, value = data_value)

> library(RColorBrewer)
> col_value<-brewer.pal(11, "Spectral")[3:10]
 
> pie(pie_data$value, col = col_value, xaxt = "n", labels = paste(pie_data$name, ": ", round(pie_data$value * 100 / sum(pie_data$value)), "%", sep = ""))


```  



### 面积堆积图 ###

希望动态了解整体在不同阶段的不同成分. 当不同阶段的水平值(数据分组的数目较少)时, 可以使用条形图或柱状图. 但如果数目较多, 使用条形图和柱状图将会很拥挤, 甚至会出现在一张图中放不下的情况, 此时可以使用面积堆积图.  

绘制面积堆积图需要加载ggplot2包, ggplot2包绘制图形的语法相对统一, 主要是弥补了R语言内的自带绘图函数语法相对零散的缺点.  

```  
> install.packages("ggplot2")
> library(ggplot2)

```  

绘制百分比面积堆积图  
` ggplot(data = ..., mapping = aes(...)) + geom_area(position = "fill") `  

绘制面积堆积图  
` ggplot(data = ..., mapping = aes(...)) + geom_area() `  


<table>
  <tr>
    <th colspan="2">参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td colspan="2">data</td>  <td>设置面积堆积图的源数据, 通常为数据框</td>
  </tr>
  <tr>
    <td colspan="2">mapping</td>  <td>设置数据源中与x轴, y轴以及分组和分组颜色的关系. 通常使用, aes( x = ..., y = ..., group = ..., fill = ) 来取值</td>
  </tr>
  
</table>

<table>
  <tr>
    <td rowspan="4">aes内部参数</td>  <td>x</td>  <td>指定源数据data中被映射为x轴的列</td>
  </tr>
  <tr>
    <td>y</td>  <td>指定源数据data中被映射为y轴的列</td>
  </tr>
  <tr>
    <td>group</td>  <td>指定源数据data中用于区分不同组别数据所在的列</td>
  </tr>
  <tr>
    <td>fill</td>  <td>指定源数据data中用于区分不同组别颜色数据所在的列</td>
  </tr>
</table>

```  
> y1<-sample(seq(from = 5, by = 1, length.out = 40), 10, replace = TRUE)
> y2<-sample(seq(from = 5, by = 1, length.out = 40), 10, replace = TRUE)
> y3<-sample(seq(from = 5, by = 1, length.out = 40), 10, replace = TRUE)

> plot_data<-data.frame(x = c(1:10), y = c(y1, y2, y3), group = c("value_y1", "value_y2", "value_y3"))
> ggplot(plot_data, aes( x = x, y = y, group = group, fill = group)) + geom_area()


> plot_data1<-data.frame(x = seq(from = 0, by = 3, length.out = 10), y = c(y1, y2, y3), group = c("value_y1", "value_y2", "value_y3"))
> ggplot(plot_data1, aes( x = x, y = y, group = group, fill = group)) + geom_area()


```  



### 直方图和密度曲线图 ###

如果想要研究一个变量的分布情况, 则需要使用直方图和密度曲线图.  

```  
> c1<-sample(seq(from = 0, by = 1, length.out = 50), 15, replace = TRUE) 

> hist(c1, main = "Hello 直方图", xlab = "x轴", ylab = "y轴", breaks = seq(from = 0, by = 5, length.out = 11))

> hist(c1, main = "Hello 直方图2", xlab = "x轴", ylab = "y轴", breaks = seq(from = 0, by =10, length.out = 6))

```  

hist是绘制直方图的核心函数, 通过 breaks参数可以设置统计尺度.  

直方图和柱状图类似, 但是它们表达的意义完全不同. 柱状图中各个立柱的高度直接代表取值, x轴代表样本点序列. 而在直方图中, x轴代表统计尺度, 各个立柱的高度表示各个统计尺度下样本的数目.  


当把统计尺度的间隔无限缩小时, 直方图变为了密度曲线图. 密度曲线的绘制并无其他特殊函数, 先通过density函数计算出变量的密度曲线数据, 再使用plot函数直接绘制出其曲线图.  

```  
> c2<-sample(seq(from = 10, by = 0.1, length.out = 100), 100, replace = TRUE)
> plot(density(c2), main = "Hello 密度曲线", xlab = "x轴", ylab = "y轴")
> rug(c2)

```  


## 绘图窗口操作函数 ##

par函数中的mfrow参数可以把当前活动窗口分割为子绘图区域. 其取值是 c(nrow, ncol) 形式, 分别设置行数和列数.  
` par(mfrow = c(<nrow>, <ncol>) `  

par函数不仅可以设置单一窗口内的多图布局, 还可以统一设计其他常用的点, 线, 文字等元素的参数属性值. 帮助命令 ` ?par `  


绘图窗口函数主要是指dev.&lt;xxx&gt; 的一系列函数  

<table>
  <tr>
    <th>函数形式</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>dev.new()</td>  <td>新建一个绘图窗口</td>
  </tr>
  <tr>
    <td>dev.cur()</td>  <td>返回当前活动的绘图窗口ID</td>
  </tr>
  <tr>
    <td>dev.list()</td>  <td>返回所有已经打开的绘图窗口ID</td>
  </tr>
  <tr>
    <td>dev.off( which = dev.cur() )</td>  <td>关闭指定绘图窗口, 默认关闭当前活动窗口</td>
  </tr>
  <tr>
    <td>dev.next( which = dev.cur() )</td>  <td>返回指定绘图窗口的下一个窗口的ID, 默认值为当前活动窗口</td>
  </tr>
  
  <tr>
    <td>dev.prev( which = dev.cur() )</td>  <td>返回指定绘图窗口的上一个窗口的ID, 默认值为当前活动窗口</td>
  </tr>
  <tr>
    <td>dev.set( which = dev.next() )</td>  <td>指定特定绘图窗口为当前活动窗口, 默认指定当前活动窗口的下一个窗口</td>
  </tr>
</table>









# 第4章 单指标分析 #

单指标变量, 包括描述性分析, 质量控制, 样本差异对比.  

> (1) 单指标分析  是指为了让分析者对指标数值有一个整体的感知, 便于同其他行业网站或者网站内的其他分类情况进行同指标对比. 例如, 研究页面浏览量的平均数和数据分布, 研究用户访问深度.  
> (2) 单指标质量控制  用于衡量该指标的日常异常点, 并了解短期波动趋势, 便于及时发现网站的异常.  
> (3) 单指标样本差异对比  用于衡量相同指标在不同情况下是否具有显著性的差异. 本质上这已经不是单纯地研究单指标了, 而是在考虑其他分类变量对该指标是否产生了显著的影响.  
> (4) 单指标样本间关联性  针对点击流(序列关系的样本)模型的样本, 找到样本间的关联性.  


## 指标描述 ##

### 平均值和集中趋势 ###

在R语言中使用 ` mean(x, trim = 0, na.rm = FALSE) ` 来计算均值. 其中x是向量(或矩阵, 数组, 数据框), 它涵盖了样本的数据信息.  
na.rm参数用于设置对默认值NA的处理方式, 取值为TRUE时, 允许样本中包含NA, 否则不允许.  

```  
> b1<-sample(seq(from = 1, by = 2, length.out = 100), 20, replace = TRUE)
> b1
 [1] 159  33 123   1 121  33  65  17  29 173  37  19  61  35 155 121 101 149
[19] 133  69
> mean(b1, trim = 0, na.rm = FALSE)
[1] 81.7
> mean(b1, trim = 0, na.rm = TRUE)
[1] 81.7
> mean(b1, trim = 0.5, na.rm = TRUE)
[1] 67


```  

在分析网站数据时, 平均数虽然是最常见的衡量指标, 但是我们往往会忽略一个前提, 那就是该指标的样本取值是有明显的集中趋势或者说该指标是服从正态分布的. 因此在使用一个平均数来衡量一个指标前, 要先绘制其样本的直方图. 并检验其是否符合正态分布.  
一旦不符合正态分布, 则需要考虑以下两个问题:  
1) 该指标是否会受其他分类变量的影响, 而导致其不具有集中趋势.  
2) 该指标是否本身就没有集中趋势.  

即使符合正态分布, 分析人员仍要提醒自己, 样本本身是否存在问题, 从而导致一些分类变量对该指标的影响作用没能体现出来.  

### 正态分布 ###
QQ图用于检验指标样本是否服从某种分布状态, 样本越是服从某种分布规律, 绘制的QQ图越会趋于一条曲线. 在R语言中使用qqnorm函数来绘制正态分布的QQ图. qqline函数则用于绘制QQ图的近似曲线, 其解析式为 y = ax + b. 其中, 斜率a是正态分布中的标准差, 截距b是均值.  

```  
> qq1<-(sample( seq(from = 5, by = 1, length = 10), 10, replace = TRUE))

> qqnorm(qq1, main = "QQ图测试")
> qqline(qq1)

```  

不论是直方图, 还是QQ图, 都是通过图形的方式检验样本是否服从正态分布, 而shapiro.test函数则可以通过向量化来判定这个问题.  

```  
> qq1<-sample(seq(from = 10, by = 1, length.out = 20), 15, replace = TRUE)
> qq1
 [1] 18 21 25 19 11 27 25 19 23 15 22 27 18 15 16
 
> test1<-shapiro.test(qq1)
> test1

        Shapiro-Wilk normality test

data:  qq1
W = 0.96111, p-value = 0.7117

> test1$p.value
[1] 0.7117171

```  

如果test1$p.value 大于显著性水平0.05, 则可以说该样本向量服从正态分布, 并且该数值越接近于1越好.  


在很多数据分析的算法中, 都要求被处理的数据服从正态分布. 处理非正态化数据:  
1) 差分处理diff  在做差分处理后, 其很有可能会服从正态分布(主要看散点图和直线的拟合程度).  
2) log对数处理  如果数据不是呈线性逐步下降, 而是呈对数急剧下降, 那么可以使用log函数对其进行对数处理.  


### 频数分析 ###
当某一指标不符合正态分布, 甚至连集中趋势都不明显时, 此时只能回归到使用频数分析来确定不同范围下样本的比例.  
先使用cut函数依据子范围把指标转化为分类变量. 然后使用table函数统计各子范围内样本的数目. 然后使用barplot函数绘制柱状图.  


### 描述性指标 ###

**平均数**  mean函数计算平均值, weighted.mean函数可以计算加权处理后的平均值.  

```  
> m1<-sample(seq(from = 10, by = 1, length.out = 100), 15, replace = TRUE)
> m1
 [1]  37  96  90  84  48  93  47  84  59  69  13  86 102  60  42
> mean(m1)
[1] 67.33333

> weighted.mean(m1, c(11:25))
[1] 66.39259

```  

**样本求和**  R语言中使用sum函数求和. 对指标加权求和, 可以使用 weighted.mean函数, 或者 sum(&lt;向量1&gt; * &lt;向量2&gt;)  
```  
> m1<-sample(seq(from = 1, by = 1, length.out = 100), 15, replace = TRUE)
> m1
 [1] 48 10 76 67 86 71 93 77 13  3  2 44 11  8  2

> sum(m1)
[1] 611
> weighted.mean(m1, 1:15)
[1] 30.575
> weighted.mean(m1, 1:15)*sum(1:15)
[1] 3669
> sum(m1 * c(1:15))
[1] 3669

```  

**中位数**  是指数据排列位于中间位置的数据. 如果数据的分布呈对称形态, 则中位数与平均数很相近. 中位数的一个特点是, 不易受异常大或异常小的影响. 在R语言中会使用median函数来计算中位数.  

```  
> m1<-sample(seq(from = 1, by = 1, length.out = 100), 16, replace = TRUE)
> m1
 [1] 13 15 39 13 41 26 80 54 84 30 32  9 48 40 19  4
> median(m1)
[1] 31

> m1<-sample(seq(from = 1, by = 1, length.out = 100), 15, replace = TRUE)
> m1
 [1] 85 32 37  8 16 85 20 38 82 87 32 66 91 12 86
> median(m1)
[1] 38

```  

**极差和五数总括** min函数计算最小值, max函数计算最大值, 极差为最大值减最小值.  
计算指标的中位数, 上/下四分卫, 以及最大/最小值这5个数据叫五数总括. 在R语言中使用fivenum函数来计算这5个数据.  
```  
> m1<-sample(seq(from = 10, by = 1, length.out = 100), 10, replace = TRUE)
> m1
 [1] 37 86 89 36 78 63 95 15 74 77

> min(m1)
[1] 15
> max(m1)
[1] 95
> max(m1) - min(m1)
[1] 80
> fivenum(m1)
[1] 15.0 37.0 75.5 86.0 95.0


```  

**百分位数**  是中位数和五数总括的扩展. 在R语言中使用quantile函数计算百分数位, 默认情况下计算0%, 25%, 50%, 75%, 100%这5个百分数位.  
```  
> m1<-sample(seq(from = 1, by = 1, length.out = 100), 15, replace = TRUE)
> m1
 [1] 58 47 87  9 15 44 57 17 82 49 77 62 85 99 35

 > quantile(m1)
  0%  25%  50%  75% 100% 
 9.0 39.5 57.0 79.5 99.0 

 > fivenum(m1)
[1]  9.0 39.5 57.0 79.5 99.0

```  

方差和标准差可衡量指标样本的离散趋势. var函数计算指标的方差. 标准差是方差的正平方根, 使用sd函数来计算指标的标准差.  
```  
> m1<-sample(seq(from = 1, by = 1, length.out = 100), 15, replace = TRUE)
> m1
 [1] 15 43 37  6 51 97 14 45 93 77 27  5 80  1  1

 > var(m1)
[1] 1148.552
> sd(m1)
[1] 33.8903
> fivenum(m1)
[1]  1 10 37 64 97

```  
















