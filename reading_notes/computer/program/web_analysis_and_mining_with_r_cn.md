
web_analysis_and_mining_with_r_cn  
Web Analysis and Mining With R  
**R语言与网站分析**  
李明/著  


个人博客:   www.bassary.com (无法访问)   
QQ邮箱:   568677413@qq.com  


# 第一章  统计思维与网站分析 #

现代统计学的很多理论均是在正态分布的基础上发展起来的. 一旦某一变量服从正态分布, 就可以使用对应的统计学理论来预测该不确定性变量的预测估值及其范围, 并可以给出该预测值的可信度.  

在统计学中除了正态分布以外, 还有很多典型分布. 网站统计分析的基础是: 找到一个服从某种分布(主要是正态分布)的变量, 用以衡量网站绝大部分用户(而非某一特定用户)的整体性能.  

## 统计分析方法 ##

网站分析一般有以下几种基础的思维方法, 也是大多数统计的方法.  
> (1) 细分分析.  网站分析的基础是找出服从正态分布(或其他分布)的变量, 细分分析是最主要的方式.  
> (2) 对比分析.  在细分分析后, 进一步使用对比分析来找到指标变量变化的真实原因.  
> (3) 趋势分析.  主要是研究指标变量的上升下降, 以及周期性等趋势性分析指标的异常变动.  


引流指标包括  浏览量(PV), 访问次数, 访客数(UV), 新访客数, 新访客比率 等等.  
黏性指标涉及  跳出率, 平均访问时长, 平均访问页数 等等.  
产出指标包含了  转化次数, 转化率 两个指标.  


# 第二章  R语言数据操作基础 #

R涉及两个含义, 它即表示一种用于数据分析建模以及绘图的语言. 又指一个有着统计分析功能及强大作图功能的软件系统. R语言是由新西兰奥克兰大学的Ross Ihaka和Robert Gentleman共同创建的. 因为它们把该语言称为R. 该语言在GUN协议 General Public Licence 4免费发行, 现在由"R开发核心团队"负责开发. 由于R语言是由AT&T贝尔实验室所创的S语言发展出的一种语言, 因此, 通常情况下使用S语言编写的代码都可以不做任何修改地在R环境下运行.  

R软件是一个免费的自由软件, 在R的安装程序中只包括8个基础模块. 其他扩展的算法包可以通过CRAN获得. 全球有超过100个CRAN镜像站.  

新用户可以通过 [http://cran.r-project.org/mirrors.html](http://cran.r-project.org/mirrors.html) 浏览CRAN镜像站地址, 包含中国大陆地区的镜像地址.  
这里使用[http://mirror.bjtu.edu.cn/cran/](http://mirror.bjtu.edu.cn/cran/)  

getwd() 命令可以读取工作目录的路径.  
setwd() 命令可以设置工作目录.  
```  
> setwd("C:/MyData/R")
> getwd()
[1] "C:/MyData/R"

> setwd(paste(getwd(),"/demo1",sep=""))
> getwd()
[1] "C:/MyData/R/demo1"


```  

R采用的是UNIX路径规则, 对于Windows系统的用户来说, 如果在路径中使用了Windows常用的"/"作为目录层级间隔符, 则会出错.  

可按上下方向键查看之前输入过的历史命令, 输入命令后, 按Enter键即可显示结果.  

sink() 命令可以将所有后续的输出由终端转向一个外部文件.  
```  
> sink("C:/MyData/R/demo1/demo.txt")
> getwd()
> getwd()
> sink()
> getwd()
[1] "C:/MyData/R/demo1"

```  

source 命令可批量执行命令脚本文件.  
```  
# demo1.r
print("Current workdir is " )
print(getwd())
print("")
print("Finish source command test!!! ")
# print("完成source命令测试")


```  
source命令时, 中文有乱码.  
```  
> source("C:/MyData/R/demo1/demo1.r")
[1] "Current workdir is "
[1] "C:/MyData/R/demo1"
[1] ""
[1] "Finish source command test!!! "
 
```

运行R时, 所有变量, 数据, 函数及结果都是以对象(Object)的形式存在计算机的活动内存中. 此时内存中的所有对象数据称为工作空间数据. 可以用save.image()函数把工作空间数据转存于硬盘中.  
` > save.image("C:/MyData/R/demo1/demo1.RData") `  

一般在处理大数据挖掘项目时, 前期的数据处理最为耗时. 此时通常会把项目中有关数据处理的命令单独制成脚本(可命名为init.data.r). 并在脚本文件最后使用save.image()语句把数据存于硬盘.  
在后续的数据分析脚本(可命名为sol.data.r), 可使用load()命令先载入数据处理脚本产生的对象数据. 这样, 在修整分析脚本时, 就不必再在数据处理阶段耗费时间了.  

&lt;R软件安装目录&gt;/doc/html/index.html 是其帮助文件的存储路径, 可以使用 help.start() 命令打开.  
```  
> help.start()
如果什么都不发生的话，你应该自己打开‘http://127.0.0.1:17185/doc/html/index.html’
```  

## R语言介绍 ##

R是一种解释性语言, 而不是编译语言. 也就是说, 输入的命令能够直接执行.  

R函数都存在一个库(library)中, 该库位于R软件的安装目录 /library 目录下. base包是R语言的核心包, 直接嵌于R软件安装包中, 它包含了数据读写, 操作最基本的函数.  

R对大小写很敏感. 即Z和z的含义是不同的变量名, 同一字母的大写和小写分别代表不同的变量对象. 另外, R对象名称不能以数字开始.  

R工作空间可存储变量和函数对象, 但是对于求值及打印命令, 并不会保存输出结果.  

R语言的注释标识是以井号(#)开始, #后面所跟的都是注释, 直到此行结束为止.  

使用 install.packages() 可以在命令行模式下安装包.  

使用 library() 或者 require() 可以在命令行模式下将已经安装好的包加载至工作空间内.  


从变量声明的角度区分, 数据类型可以分为静态类型和动态类型.  
在编译期间就确定数据类型的语言, 叫静态类型语言. 该类语言要求在使用任一变量之前必须先声明其数据类型. 例如, Java和C就是静态类型语言.  
在运行期间才确定数据类型的语言, 叫动态语言语言. 对于该类语言, 不必事先声明其数据类型, 而是通过第一次的赋值来定义其数据类型. R和Python为动态类型语言.  


从不同数据类型是否可混合使用的角度来区分, 语言又可以分为弱类型语言和强类型语言.  
在弱类型语言中, 不同数据类型间的数据可以混合使用. 例如, VBScript中, 可以将字符串'12'和整数3进行连接, 从而得到字符串'123'.  
在强类型语言中则相反, 不同数据类型间的数据不可以混合使用. 必须通过类型转化函数处理后才可以. R和Python就是强类型语言.  


## R数据类型 ##
R的数据类型有 数值型, 字符型, 复数型 和 逻辑型 .  
**数值(numeric)类型**的取值是实数, 在R环境中使用数字来表示.  
```  
> a<-9.111
> mode(a)
[1] "numeric"

> a<-12345
> mode(a)
[1] "numeric"

```  


**字符(character)类型**的取值是字符串, 在R语言中, 字符串需要使用英文双引号括起来表示.  
```  
> a<-"abcd123"
> mode(a)
[1] "character"

> a<-"Hello World!"
> mode(a)
[1] "character"

```  


**复数(complex)类型**的取值可扩展到虚数, 并使用&lt;实部数值&gt;+i&lt;虚部数值&gt;来表示.  
如果有数平方是负数的话, 那个数就是虚数. 所有的虚数都是复数.  
```  
> a<-100+11i
> mode(a)
[1] "complex"

> a<-10+123i
> mode(a)
[1] "complex"

```  

**逻辑(logical)类型**的取值为TRUE(也可以简写为T)和FALSE(也可以简写为F).  
```  
> a<-T
> mode(a)
[1] "logical"

> a<-FALSE
> mode(a)
[1] "logical"

```  

有两种特殊情况不能使用上述4种数据类型来描述, 数据的缺失和数据的未知状态.  
NA 表示数据集中的某数据缺失.  
NULL 表示未知的状态.  


最能说明NULL和NA区别的是, 当读取向量的长度时.  
NULL不占据任何工作空间, length(c(1,2,3,NULL,4))的返回值为4.  
而NA是占据工作空间的, length(c(1,2,3,NA,4))的返回值是5.  

```  
> length(c(1,2,3,NULL,4))
[1] 4

> length( c( 1, 2, 3, NULL, 4 ) )
[1] 4


> length(c(1,2,3,NA,4))
[1] 5

> length( c( 1, 2, 3, NA, 4) )
[1] 5

```  

有时判断一个数据是否为NA或NULL, 这时可以使用is.na和is.null函数.  
```  
> a<-c( 1, 2, 3, NA, 4, NULL, 5)
> is.na(a)
[1] FALSE FALSE FALSE  TRUE FALSE FALSE
> is.null(a)
[1] FALSE

```  

## 对象及其属性 ##

R语言内部数据变量, 函数结果, 产生的图像等, 都是以对象形式存在的. 不过由于R语言并非编程语言, 并且R语言的用户也非软件专业出身. 所以本书将会弱化函数和图像的对象概念, 更多强调的是数据变量的对象概念.  

R语言给出的常用对象有 向量(vector), 数组(array), 矩阵(matrix), 数据框(data frame), 列表(list) 等. 其中, 数据框和列表的内部元素可以使用不同的数据类型.  
vector是一维的, matrix, list, data frame是二维的, array是多维的.  

对象类型是指R语言组织和管理内部元素的不同方式, 数据类型则描述了一个变量内元素取值的类型.  

**不同对象类型元素取值的数据类型**
<table>
  <tr>
    <th>对象类型</th>  <th>数据类型</th>  <th>是否允许出现不同数据类型</th>
  </tr>
  
  <tr>
    <td>向量</td>  <td>数值型, 复数型, 字符型, 逻辑型</td>  <td>不允许</td>
  </tr>
  <tr>
    <td>因子</td>  <td>数值型, 复数型, 字符型, 逻辑型</td>  <td>不允许</td>
  </tr>
  <tr>
    <td>数组</td>  <td>数值型, 复数型, 字符型, 逻辑型</td>  <td>不允许</td>
  </tr>
  <tr>
    <td>矩阵</td>  <td>数值型, 复数型, 字符型, 逻辑型</td>  <td>不允许</td>
  </tr>
  <tr>
    <td>数据框</td>  <td>数据型, 复数型. 字符型, 逻辑型</td>  <td>相同列内元素, 其数据类型必须相同; 不同列之间的数据类型可以不同</td>
  </tr>
  <tr>
    <td>列表</td>  <td>数据型, 复数型, 字符型, 逻辑型</td>  <td>任何元素的数据类型均可不同</td>
  </tr>
  <tr>
    <td>时间序列</td>  <td>数值型, 复数型, 字符型, 逻辑型</td>  <td>不允许</td>
  </tr>
</table>


R语言使用属性来辅助性描述每个对象信息, 使用mode函数可以读取对象的模式(数据类型), 使用 as.&lt;数据类型&gt; 可以改变对象的模式.  
```  
> a<-"100"
> mode(a)
[1] "character"
> a<-as.numeric(a)
> mode(a)
[1] "numeric"


> a<-"100"
> mode(a)
[1] "character"
> a<-as.complex(a)
> mode(a)
[1] "complex"


> a<-10; b<-0
> mode(a)
[1] "numeric"
> mode(b)
[1] "numeric"
> paste("a=", as.logical(a), "b=", as.logical(b))
[1] "a= TRUE b= FALSE"
> mode(a)
[1] "numeric"



```  

使用length函数获取对象的长度属性. 在R中, 对象长度可以是0, 并可以对超过对象长度的下标赋值. 以增加对象的元素. 赋值后对象的长度会自动增长至此下标处, 而中间未被赋值的元素会被默认赋值为缺失值NA.  
```  
> x<-numeric()
> length(x)
[1] 0
> x[2]<-1
> x[4]<-16
> x
[1] NA  1 NA 16
> length(x)
[1] 4

```  

除了固有属性length和mode外, 要了解其余的属性, 可以使用attributes()和attr()函数来查看, 并且可以对其进行修改.  
attributes()函数读取除长度和模式以外的所有属性, 使用attr(&lt;对象&gt;, "names")读取列名属性. 其返回结果为向量, 并可以直接赋值, 以修改该属性.  
```  
> x<-numeric()
> x[3]<-6
> attributes(x)
NULL



> x<-data.frame(name1=c(1:5), name2=c("c1,","c2","c3","c4","c5"))
> attributes(x)
$names
[1] "name1" "name2"

$row.names
[1] 1 2 3 4 5

$class
[1] "data.frame"

> attr(x, "names")
[1] "name1" "name2"
> attr(x, "row.names")
[1] 1 2 3 4 5


> attr(x, "names")[1]<-"name_a"
> attr(x, "names")
[1] "name_a" "name2" 


```  

一旦某个对象过于庞大, 就往往会影响R软件环境的运行速度. 此时需要查看工作空间内现存的对象列表, 并删除其中的某个对象.  
```  
> ls()
[1] "a" "b" "s" "x"
> rm(a)
> a
错误: 找不到对象'a'


> rm(list=ls())
> ls()
character(0)

```  




## 向量 ##

向量是以一维数组的方式管理数据的一种对象类型, 可以说向量是R语言中最基本的对象类型. 很多算法都是以向量的形式输入的.  

R语言使用 c(&lt;元素1&gt;, &lt;元素2&gt;, ..., &lt;元素n&gt;) 来创建向量, 向量内各元素使用逗号分隔.  
```  
> a1<-c(1, 2, 3, 4)
> mode(a1)
[1] "numeric"

> a2<-c("test1", "test2", "test3", "test4")
> mode(a2)
[1] "character"

> a3<-c(T, F, T, F)
> mode(a3)
[1] "logical"



> a1_2<-c(1, 2, "test1", "test2")
> mode(a1_2)
[1] "character"


> a1_3<-c(1, 2, T, F)
> mode(a1_3)
[1] "numeric"


> a2_3<-c("test1", "test2", T, F)
> mode(a2_3)
[1] "character"



```  

R语言下标索引与其他类型语言的最大区别就是, 下标始于1, 而非0. 可使用**向量对象[下标]** 方式读取该下标的元素, 并且可用 **向量对象[-下标]** 方式读取除该下标元素外的其他元素.  
```  
> a<-c("test1", "test2", "test3", "test4")
> 
> a[1]
[1] "test1"
> a[-1]
[1] "test2" "test3" "test4"


> a[c(1, 3)]
[1] "test1" "test3"
> a[-c(1, 3)]
[1] "test2" "test4"


```  
除了使用一个数据作为下标, 还可以使用一个向量.  


使用which函数可以通过向量内元素的数值, 来得到此元素的向量下标. 如果有多个元素符合筛选要求, 则以向量方式返回多个下标.  
```  
> a<-c("test1", "test2", "test3", "test4")
> a
[1] "test1" "test2" "test3" "test4"


> which(a=="test1")
[1] 1
> which(a=="test3")
[1] 3

> which(a==c("test1", "test2"))
[1] 1 2
> which(a==c("test1", "test3"))
[1] 1
> which(a==c("test1", "test4"))
[1] 1 4

> which(a!="test2")
[1] 1 3 4
> 

```
which比较时, 会延长短向量与长向量一致, 再进行比较.  

对于数值类型的向量, 不仅可以使用等于和不等于方式来返回向量下标, 还可以使用大于或小于等方式返回.  
```  
> a<-c(101, 102, 103, 104)
> a

[1] 101 102 103 104
> which(a>102)
[1] 3 4

> which(a<=103)
[1] 1 2 3

> which(a>102 & a<=103)
[1] 3

> which(a>102 | a<=103)
[1] 1 2 3 4


> which.min(a)
[1] 1
> which(a==min(a))
[1] 1


> which.max(a)
[1] 4
> which(a==max(a))
[1] 4


> a[which(a>102 & a<=103)]
[1] 103

```  

which.max和which.min用于返回数值型向量中最大值和最小值元素的下标.  


subset函数可以方便地索引向量, 矩阵以及函数.  
```  
> a<-c(101, 102, 103, 104)
> subset(a, a > 102 & a <= 103)
[1] 103
# same to a[which(a > 102 & a <= 103)]

```  


match可以称作匹配函数, 形式为  
` match(x, table, nomatch = NA_integer_, incomparables = NULL) `  

<table>
  <tr>
    <th>参数>  <th>说明</th>
  </tr>
  
  <tr>
    <td>X</td>  <td>查询的对象</td> 
  </tr>
  <tr>
    <td>table</td>  <td>匹配的数值, 可以是向量形式</td>
  </tr>
  <tr>
    <td>nomatch</td>  <td>如果不匹配, 返回的数值, 默认返回缺失值NA</td>
  </tr>
  <tr>
    <td>incomparables</td>  <td>设置table参数中无效的匹配值, 默认不设置, 即为NULL<td>
  </tr>
</table>

```  
> a<-c(101, 101, 102, 102, 103, 103, 104, 104, NA, 101, NA, 102)
> a
 [1] 101 101 102 102 103 103 104 104  NA 101  NA 102

 
> match(a, c(101, 103))
 [1]  1  1 NA NA  2  2 NA NA NA  1 NA NA
 
> match(a, c(101, 103), nomatch = 0)
 [1] 1 1 0 0 2 2 0 0 0 1 0 0

 
> match(a, c(101, 103), nomatch = 0, incomparables = 1000)
 [1] 1 1 0 0 2 2 0 0 0 1 0 0
 
> match(a, c(101, 103), nomatch = 0, incomparables = 103)
 [1] 1 1 0 0 0 0 0 0 0 1 0 0
 
> match(a, c(101, 103), nomatch = 0, incomparables = 101)
 [1] 0 0 0 0 2 2 0 0 0 0 0 0
 
 
```  


%in%命令可以判定对象是否包含某项数据, 如果存在则返回T, 如果不存在则返回F.  
```  
> a<-c(101, 101, 102, 103, 104, 104, 103, 102)

> c(101, 105, 106)%in%a
[1]  TRUE FALSE FALSE

> c(103, 105, 101)%in%a
[1]  TRUE FALSE  TRUE


```  

在R语言中, 修改向量内某元素很简单, 只要通过索引找出特定的元素. 然后直接使用 <- 进行赋值即可. R语言还提供了扩展向量和删除元素的功能.  

R可以对对象长度进行任意扩展, 例如, c(&lt;向量1&gt;, &lt;向量2&gt;, ..., &lt;向量n&gt;) 即可将n个向量合并.  
```  
> a<-c(1, 2, 3, 4)
> a
[1] 1 2 3 4


> a<-c(a, c(101, 102, 103))
> a
[1]   1   2   3   4 101 102 103

```  

要删除向量内某一元素, 可使用对向量重新赋值的方式实现. 例如, a[-3]表示向量a中除了第三个元素以外的所有元素. 把它重新赋予a后实现删除a[3]的效果.  
```  
> a<-c(101, 102, 103, 104)
> a
[1] 101 102 103 104

> a<-a[-3]
> a
[1] 101 102 104
> length(a)
[1] 3

```  

R语言可以依据数值的大小使用sort进行排序, 使用rev依据下标进行倒排序. 结合sort和rev使用 rev(sort(&lt;向量&gt;)) , 可以对向量依据大小进行倒排序.  
```  
> a<-c(95, 98, 96, 97, 106, 101, 102, 104, 103)
> a
[1]  95  98  96  97 106 101 102 104 103

> rev(a)
[1] 103 104 102 101 106  97  96  98  95

> sort(a)
[1]  95  96  97  98 101 102 103 104 106

> rev(sort(a))
[1] 106 104 103 102 101  98  97  96  95

> rev(rev(sort(a)))
[1]  95  96  97  98 101 102 103 104 106


```  

希望删除向量内重复的元素, 这时可以使用 unique() 来实现.  
```  
> a<-c(95, 97, 96, 95, 94, 99, 98, 97 ,96)
> a
[1] 95 97 96 95 94 99 98 97 96
> unique(a)
[1] 95 97 96 94 99 98

```  

此功能同样可以使用table函数来实现, 不过比较麻烦.  
```  
> a<-c(95, 97, 96, 95, 94, 99, 98, 97 ,96)
> a
[1] 95 97 96 95 94 99 98 97 96
> as.numeric(names(table(a)))
[1] 94 95 96 97 98 99

```  

实际工作中, 数据集很少是完整的, 许多情况下样本都会包括若干缺失值NA. 这在进行数据分析和挖掘时比较麻烦. R语言通过 na.fail 和 na.omit 函数可以很好地处理样本中的缺失值.  

<table>
  <tr>
    <th>函数</th>  <th>用法</th>  <th>说明</th>
  </tr>

  <tr>
    <td>na.fail</td>  <td>na.fail(&lt;向量a&gt;)</td>  <td>如果向量a内包括至少一个NA, 则返回错误; 如果不包括任何NA, 则返回原有向量. </td>
	
  </tr>
  <tr>
    <td rowspan="2">na.omit</td>  <td>na.omit(&lt;向量a&gt;)</td>  <td>返回删除NA后的向量a</td>
  </tr>
  <tr>
    <td>attr(na.omit(&lt;向量a&gt;), "na.action")</td>  <td>返回向量a中元素为NA的下标</td>
  </tr>
</table>

```  
> a0<-c(95, 99, 97, 93, 96)
> a0
[1] 95 99 97 93 96
> a1<-c(95, 99, 97, NA, 96)
> a1
[1] 95 99 97 NA 96
> a2<-c(95, NA, 97, 93, NA)
> a2
[1] 95 NA 97 93 NA


> na.fail(a0)
[1] 95 99 97 93 96
> na.fail(a1)
Error in na.fail.default(a1) : 对象里有遺漏值
> na.fail(a2)
Error in na.fail.default(a2) : 对象里有遺漏值


> na.omit(a0)
[1] 95 99 97 93 96
> na.omit(a1)
[1] 95 99 97 96
attr(,"na.action")
[1] 4
attr(,"class")
[1] "omit"
> na.omit(a2)
[1] 95 97 93
attr(,"na.action")
[1] 2 5
attr(,"class")
[1] "omit"


> attr(na.omit(a0), "na.action")
NULL
> attr(na.omit(a1), "na.action")
[1] 4
attr(,"class")
[1] "omit"
> attr(na.omit(a2), "na.action")
[1] 2 5
attr(,"class")
[1] "omit"


```  

函数na.fail和na.omit不仅可以应用于向量, 也可以应用于矩阵和数据框. 另外, 还可以使用 !x 方式方便地删除NA.  
```  
> t<-c(95, 99, 97, NA, 101, 106, NA, 104)
> t
[1]  95  99  97  NA 101 106  NA 104

> t[!is.na(t)]
[1]  95  99  97 101 106 104

```  


使用 pmin(&lt;向量1&gt;, &lt;向量2&gt;, ..., &lt;向量n&gt;) 可以依次比较向量1至向量n内的各元素, 并把较小的元素组成新的向量. pmax则是把较大的元素组成新的向量.  
```  
> a<-c(1, 2, 3, 4, 5)
> a
[1] 1 2 3 4 5
> b<-c(1, 3, 5, 7, 9)
> b
[1] 1 3 5 7 9
> c<-c(2, 3, 6, 7, 9)
> c
[1] 2 3 6 7 9
> d<-c(2, 3, 2, 4, 10, 12, 13)
> d
[1]  2  3  2  4 10 12 13


> pmin(a, b, c, d)
[1] 1 2 2 4 5 1 2
Warning message:
In pmin(a, b, c, d) : 参数值将数据略微回收

> pmin(d, a, b, c)
[1] 1 2 2 4 5 1 2
Warning message:
In pmin(d, a, b, c) : 参数值将数据略微回收

> pmax(a, b, c, d)
[1]  2  3  6  7 10 12 13
Warning message:
In pmax(a, b, c, d) : 参数值将数据略微回收

> pmin(a, b, c)
[1] 1 2 3 4 5
> pmax(a, b, c)
[1] 2 3 6 7 9


> intersect(a, b)
[1] 1 3 5
> intersect(b, a)
[1] 1 3 5
> intersect(a, d)
[1] 2 3 4


> union(a, b)
[1] 1 2 3 4 5 7 9
> union(b, a)
[1] 1 3 5 7 9 2 4
> union(a, d)
[1]  1  2  3  4  5 10 12 13


> setdiff(a, b)
[1] 2 4
> setdiff(b, a)
[1] 7 9
> setdiff(a, d)
[1] 1 5


```  
除了比较向量的大小外, 在处理样本间的关系时, 还有一组更常用的操作, 即 取交集, 并集, 补集.  
intersect(&lt;向量1&gt;, &lt;向量2&gt;)  返回由既属于向量1, 也属于向量2的元素(交集)所组成的向量.  
union(&lt;向量1&gt;, &lt;向量2&gt;)  返回由属于向量1或者属于向量2的元素(并集)所组成的向量.  
setdiff(&lt;向量1&gt;, &lt;向量2&gt;)  返回由属于向量1而不属于向量2的元素(补集)所组成的向量.  






## 矩阵和数组 ##

### 矩阵 ###

向量vector用于描述一维数据, 是R语言中最基础的数据结构. 然而在很多情况下. 数据是以二维甚至多维的形式存在的. 利用矩阵matrix可以描述二维数据. 和向量类似, 其内部元素可以是实数, 复数, 字符, 逻辑型数据. 矩阵matrix使用两个下标来访问元素, A[i ,j]表示矩阵第i行, 第j列的元素.  

多维数据array可以描述多维数据. array有一个特征属性叫做维数向量(dim属性), 它的长度是多维数组的维数. dim内的元素则是对应维度的长度. 假设多维数组A表示是一个四维数据, 其中第一维长度是10, 第二维长度是5, 第三维长度是8, 第四维的长度是9, 那么A的维数向量dim(A)是向量c(10, 5, 8, 9). 通过维数向量, 可以很好地描述多维数据.  

在R中, 可以使用matrix函数并以向量形式输入矩阵中的全部元素. 使用ncol和nrow可设置矩阵的行和列数. 从而创建一个矩阵.  
```  
> t<-c(1:10)
> t
 [1]  1  2  3  4  5  6  7  8  9 10
> m<-matrix(t, ncol = 2, nrow = 5)
> m
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10


```  

向量1~10的填充方式为以列为单位填充, 如果想以行为单位填充, 则可以把matrix函数的byrow参数置为T.  
```  
> t<-c(1:10)
> m<-matrix(t, ncol = 2, nrow = 5, byrow = T)
> m
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10

```  

对于matrix函数的行数参数nrow和列数参数ncol, 可以通过dim函数来获取并编辑.  
```  
> t<-c(1:10)
> m<-matrix(t)
> m
      [,1]
 [1,]    1
 [2,]    2
 [3,]    3
 [4,]    4
 [5,]    5
 [6,]    6
 [7,]    7
 [8,]    8
 [9,]    9
[10,]   10
> dim(m)<-c(2,5)
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10

```  

dim(&lt;矩阵&gt;) 是由矩阵的行数和列数这两个元素组成的向量, 称其为维数向量.  

在创建矩阵时, 可以使用dimnames参数设置行和列的名称.  
```  
> t<-c(1:10)
> m<-matrix(t, ncol = 2, nrow = 5, dimnames = list( c("r1", "r2", "r3", "r4", "r5"), c("c1", "c2")))
> m
   c1 c2
r1  1  6
r2  2  7
r3  3  8
r4  4  9
r5  5 10

> dimnames(m)
[[1]]
[1] "r1" "r2" "r3" "r4" "r5"

[[2]]
[1] "c1" "c2"


```  

dimnames参数以list列表形式进行输入.  
可以通过 dimnames(&lt;矩阵&gt;) 来读取并编辑行列名称.  

可以使用 as.vector(&lt;矩阵&gt;) 将矩阵反过来转化为向量.  
```  
> t<-c(1:10)
> m<-matrix(t, ncol = 2, nrow = 5)
> v<-as.vector(m)
> v
 [1]  1  2  3  4  5  6  7  8  9 10

```  

col是列的简称, row是行的简称.  

矩阵是用于管理二维数据的, 所以使用两个下标可以表示矩阵内的元素.  
```  
> t<-c(1:10)
> m<-matrix(t, ncol = 2, nrow = 5, dimnames = list( c("r1", "r2", "r3", "r4", "r5"), c("c1", "c2") ))
> m
   c1 c2
r1  1  6
r2  2  7
r3  3  8
r4  4  9
r5  5 10


> m[3,2]
[1] 8

> m[3, 2]
[1] 8

> m["r3", "c2"]
[1] 8

> m[[8]]
[1] 8

```  

**矩阵索引方式**  

使用行列下标来索引矩阵元素.  
对已经为行和列名称赋值的矩阵, 可以用行和列的名称来代替行列的下标.  
矩阵m实质是由一维向量c(1:10)组成的 ( as.vector(m) 为 c(1:10) ), 而矩阵m第3行第2列的元素实质就是向量c(1:10)的第8个元素, 因此可以用 m[[8]] 来表示相应的元素.  

由于二维矩阵可以看作是多个一维向量以行或列的形式组合起来的. 所以通过矩阵可以很方便地找到矩阵的某行或某列. m[i,] 返回矩阵m第i行的所有元素, 并以向量形式承载.  m[,j] 返回矩阵m第j列的所有元素, 并以向量形式承载.  
```  
> t<-c(1:10)
> m<-matrix(t, ncol = 2, nrow = 5)
> m
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10

> m[1,]
[1] 1 6
> m[, 1]
[1] 1 2 3 4 5

```  

rbind函数可以以行的形式把多个矩阵或向量合并在一起, 扩展成一个新的矩阵.  
```  
> t<-c(1:10)
> m1<-matrix(t, ncol = 2, nrow = 5)
> m1
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10


> m1.1<-rbind(m1, c(21:21))
> m1.1
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10
[6,]   21   21


> t2<-c(101:106)
> m2<-matrix(t2, ncol = 2, nrow = 3)
> m2
     [,1] [,2]
[1,]  101  104
[2,]  102  105
[3,]  103  106

> m1.2<-rbind(m1, m2)
> m1.2
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10
[6,]  101  104
[7,]  102  105
[8,]  103  106


> m1.c1<-cbind(m1, c(201:205))
> m1.c1
     [,1] [,2] [,3]
[1,]    1    6  201
[2,]    2    7  202
[3,]    3    8  203
[4,]    4    9  204
[5,]    5   10  205


```  

使用rbind扩展了矩阵的行, 使用cbind扩展了矩阵的列.  


删除矩阵内某行或某列的方式类似于向量, 实质是对矩阵进行重新赋值, 只要所赋的值不包含欲删除的行或列即可.  
```  

> t<-c(1:20)
> m<-matrix(t, ncol = 4, nrow = 5)
> m
     [,1] [,2] [,3] [,4]
[1,]    1    6   11   16
[2,]    2    7   12   17
[3,]    3    8   13   18
[4,]    4    9   14   19
[5,]    5   10   15   20

# delete a col
> m<-m[,-1]
> m
     [,1] [,2] [,3]
[1,]    6   11   16
[2,]    7   12   17
[3,]    8   13   18
[4,]    9   14   19
[5,]   10   15   20



# delete a row
> m<-m[-1,]
> m
     [,1] [,2] [,3]
[1,]    7   12   17
[2,]    8   13   18
[3,]    9   14   19
[4,]   10   15   20


```  

m[,-1] 表示矩阵m中除第1列外的所有元素, 对m重新赋值后便删除了m的第1列. 同理, m<-m[-1,]删除了第一行.  




### 矩阵的运算 ###

定义样例矩阵  

```  
> A<-matrix(c(1:12), ncol = 3, nrow = 4)
> A
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    2    6   10
[3,]    3    7   11
[4,]    4    8   12


> B<-matrix(c(4:15), ncol = 3, nrow = 4, byrow = T)
> B
     [,1] [,2] [,3]
[1,]    4    5    6
[2,]    7    8    9
[3,]   10   11   12
[4,]   13   14   15



> C<-matrix(c(12:1), ncol = 4, nrow = 3)
> C
     [,1] [,2] [,3] [,4]
[1,]   12    9    6    3
[2,]   11    8    5    2
[3,]   10    7    4    1



> D<-matrix(rnorm(16), 4, 4)
> D
           [,1]       [,2]       [,3]        [,4]
[1,] -1.4795228  0.4962877  1.6760607 -0.06728339
[2,] -0.3573371 -0.6930438 -0.3578681  0.42805317
[3,] -0.2407190  0.5765802  0.8102342 -1.05679668
[4,] -1.6204981 -1.3195070  0.2150811  0.78536755


```  

**一般运算**  

1) 矩阵的加法 (A + B): aij + bij =  (A+B)ij  
```  
> A + B
     [,1] [,2] [,3]
[1,]    5   10   15
[2,]    9   14   19
[3,]   13   18   23
[4,]   17   22   27



```  

矩阵各个元素均与一个常数相加. A + 2  
```  
> A + 2
     [,1] [,2] [,3]
[1,]    3    7   11
[2,]    4    8   12
[3,]    5    9   13
[4,]    6   10   14


```  

2) 矩阵的减法 (A - B):  aij - bij = (A - B)ij
```  
> A - B
     [,1] [,2] [,3]
[1,]   -3    0    3
[2,]   -5   -2    1
[3,]   -7   -4   -1
[4,]   -9   -6   -3


> A - 2
     [,1] [,2] [,3]
[1,]   -1    3    7
[2,]    0    4    8
[3,]    1    5    9
[4,]    2    6   10


```  

3) 矩阵间各个元素分别相乘. aij * bij  

```  
> A * B
     [,1] [,2] [,3]
[1,]    4   25   54
[2,]   14   48   90
[3,]   30   77  132
[4,]   52  112  180



> A * 2
     [,1] [,2] [,3]
[1,]    2   10   18
[2,]    4   12   20
[3,]    6   14   22
[4,]    8   16   24


```  

4) 矩阵相乘AB. (要求A的行数等于B的列数, A的列数等于B的行数)  

```R  
> A %*% C
     [,1] [,2] [,3] [,4]
[1,]  157  112   67   22
[2,]  190  136   82   28
[3,]  223  160   97   34
[4,]  256  184  112   40


```  



**转置矩阵**  

aji = (A的转置矩阵)ij. 在R语言中, 使用t函数可以实现矩阵的转置.  
```  
> t(A)
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4
[2,]    5    6    7    8
[3,]    9   10   11   12

> t(B)
     [,1] [,2] [,3] [,4]
[1,]    4    7   10   13
[2,]    5    8   11   14
[3,]    6    9   12   15


```  

**矩阵求解**  
求解DX=A中的X, 可以使用如下代码, solve函数.  

```  
> solve(D, A)
           [,1]      [,2]       [,3]
[1,] -16.357975 -83.36230 -150.36663
[2,]  10.303631  69.22663  128.14962
[3,] -17.161002 -91.91863 -166.67627
[4,]  -6.648285 -20.33885  -34.02942
> solve(B, A)
Error in solve.default(B, A) : 'a'(4 x 3)必需是正方形的


```  

**矩阵的特征值和特征向量**  

假设A是n阶方阵, 如果存在数值m和非零n维列向量x, 使得 Ax=mx成立. 则称m是A的一个特征值(characteristic value). 非零n维列向量x则成为矩阵A属于(对应于)特征值m的特征向量(characteristic vector).  简称A的特征向量或A. 通过eigen函数可以直接求解方阵D的特征值和特征向量.  
```  
> d.eigen<-eigen(D)

> d.eigen
$values
[1] -0.82115564+0.8138457i -0.82115564-0.8138457i  0.98585329+0.0000000i  0.07949321+0.0000000i

$vectors
                     [,1]                 [,2]          [,3]           [,4]
[1,] 0.6660187+0.0000000i 0.6660187+0.0000000i  0.4320569+0i  0.53632002+0i
[2,] 0.0600660+0.1257823i 0.0600660-0.1257823i -0.3505222+0i -0.52801236+0i
[3,] 0.2647123+0.2992718i 0.2647123-0.2992718i  0.7228682+0i  0.65698131+0i
[4,] 0.5201754+0.3267588i 0.5201754-0.3267588i -0.4097835+0i  0.04403808+0i



> d.eigen$values
[1] -0.82115564+0.8138457i -0.82115564-0.8138457i  0.98585329+0.0000000i  0.07949321+0.0000000i

> d.eigen$vectors
                     [,1]                 [,2]          [,3]           [,4]
[1,] 0.6660187+0.0000000i 0.6660187+0.0000000i  0.4320569+0i  0.53632002+0i
[2,] 0.0600660+0.1257823i 0.0600660-0.1257823i -0.3505222+0i -0.52801236+0i
[3,] 0.2647123+0.2992718i 0.2647123-0.2992718i  0.7228682+0i  0.65698131+0i
[4,] 0.5201754+0.3267588i 0.5201754-0.3267588i -0.4097835+0i  0.04403808+0i



> d.eigen$values[2]
[1] -0.8211556-0.8138457i

> d.eigen$vectors[2]
[1] 0.060066+0.1257823i

> d.eigen$vectors[,2]
[1] 0.6660187+0.0000000i 0.0600660-0.1257823i 0.2647123-0.2992718i 0.5201754-0.3267588i



```  

其中eigen(&lt;方阵&gt;)$values 为方阵的特征值. eigen(&lt;方阵&gt;)$vectors 为方阵的特征向量. 在上例中, 方阵D的特征值有4个, 第i个特征值 d.eigen$values[i] 对应的特征向量为 d.eigen$vectors[,i] .  



### 数组 ###

矩阵可以看成是一个特殊的多维数组(维数为2). 在数组中, 也有维数向量概念. 只是其长度不再只是等于2了. 可使用array函数并设置维数向量来创建一个多维数组.  

```  
> data<-array( c(1:30), dim = c( 2, 5, 3))
> data
, , 1

     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10

, , 2

     [,1] [,2] [,3] [,4] [,5]
[1,]   11   13   15   17   19
[2,]   12   14   16   18   20

, , 3

     [,1] [,2] [,3] [,4] [,5]
[1,]   21   23   25   27   29
[2,]   22   24   26   28   30


> dim(data)
[1] 2 5 3





> ay<-array( c(1:120), dim = c(2, 5, 3, 4))
> ay
, , 1, 1

     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10

, , 2, 1

     [,1] [,2] [,3] [,4] [,5]
[1,]   11   13   15   17   19
[2,]   12   14   16   18   20

, , 3, 1

     [,1] [,2] [,3] [,4] [,5]
[1,]   21   23   25   27   29
[2,]   22   24   26   28   30

, , 1, 2

     [,1] [,2] [,3] [,4] [,5]
[1,]   31   33   35   37   39
[2,]   32   34   36   38   40
# 此处省略后续打印数据

```  

上面表示建立一个三维数据的数组, 其维度是 ` 2 * 5 * 3 ` , 在结果中会依次展示了3个2行5列的矩阵. dim函数同样可以用于多维数组中.  

由于数组是用于描述多维数据的, 所以数组的索引需要用到多个下标.  
data[1, 2, 3]对第三个 ` 2 * 5 ` 矩阵中第1行, 第2列元素(23)进行了索引.  
data[, 3, ]则表示由第二维度下标是3的全部元素组成的二维数据.  
```  
# data<-array( c(1:30), dim = c( 2, 5, 3))

> dim(data)
[1] 2 5 3


> data[1, 2, 3]
[1] 23
> data[, 3, ]
     [,1] [,2] [,3]
[1,]    5   15   25
[2,]    6   16   26

 
> data[, , 3]
     [,1] [,2] [,3] [,4] [,5]
[1,]   21   23   25   27   29
[2,]   22   24   26   28   30


```  

apply函数可以读取多维数组中某个维度的所有数据, 并应用其他函数进行数据处理. apply函数的基本形式为:  
` apply(x, MARGIN, FUN) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>X</td>  <td>多维数组array</td>
  </tr>
  <tr>
    <td>MARGIN</td>  <td>预处理的维数</td>
  </tr>
  <tr>
    <td>FUN</td>  <td>多维数组中某一维度元素的处理函数</td>
  </tr>
</table>


```  
> data<-array( c(1:30), dim = c(2, 5, 3))

> apply(data, 3, sum)[1]
[1] 55
> apply(data, 3, sum)[2]
[1] 155
> apply(data, 3, sum)[3]
[1] 255


> apply(data, 3, sum)
[1]  55 155 255

> sum(data[, , 1])
[1] 55


> apply(data, 1, sum)[1]
[1] 225
> apply(data, 1, sum)[2]
[1] 240
> apply(data, 1, sum)[3]
[1] NA


```  

上例中的data数据是一个三维数据, 其中第三维的下标是1~3, apply(data, 3, sum)[1] 用于计算多维数组data中第三维下标为1的所有元素的总和(fun参数为sum取和函数). 当然, 该功能也可以通过 sum(data[, , 1]) 来实现.



## 列表和数据框 ##

列表list和数据框data.frame也是一个二维数据. 其中向量vector, 多维数组array以及矩阵matrix存储的元素, 其数据类型是唯一的. 列表和数据框内每列元素的数据类型可以不同. 列表内每列的长度也可以不同. 一般, 在使用R语言进行数据分析和挖掘的过程中, 向量和数据框的使用频率是最高的. list则在存储较复杂的数据时作为数据对象.  

### 列表 list ###

list()函数可以用于创建列表对象.  
```  
> l<-list( a = c(1, 2, 3), b = c("one", "two"), c = T, d = c(3i+4, 9i-9))
> l
$a
[1] 1 2 3

$b
[1] "one" "two"

$c
[1] TRUE

$d
[1]  4+3i -9+9i


```  

每列内元素的数据类型可以不同, 而且列名内元素的长度也可以不同. 但是相同列中的元素类型相同. 对于向量索引, 即可以直接使用列下标 &lt;list对象&gt;[[下标]] 的形式. 也可以使用列名称 &lt;list对象&gt;[["列名称"]] 或 &lt;list对象&gt;$列名称 的形式.  
```  
>  l<-list( a = c(1, 2, 3), b = c("one", "two"), c = T, d = c(3i+4, 9i-9))

> l[[1]]
[1] 1 2 3
> l[[2]]
[1] "one" "two"

> l[["a"]]
[1] 1 2 3

> l$A
NULL
> l$a
[1] 1 2 3


```  

列表内的元素不仅可以是不同数据类型的向量或数据, 也可以是一个列表, 即可以使用列表的嵌套来建立更复杂的数据.  
```  
> l1<-list( list("data1", 2, T), c(101:106), c(T, F, F, T))
> l1
[[1]]
[[1]][[1]]
[1] "data1"

[[1]][[2]]
[1] 2

[[1]][[3]]
[1] TRUE


[[2]]
[1] 101 102 103 104 105 106

[[3]]
[1]  TRUE FALSE FALSE  TRUE

> l2<-list(l1, c("new1", "new2", "new3"))
> l2
[[1]]
[[1]][[1]]
[[1]][[1]][[1]]
[1] "data1"

[[1]][[1]][[2]]
[1] 2

[[1]][[1]][[3]]
[1] TRUE


[[1]][[2]]
[1] 101 102 103 104 105 106

[[1]][[3]]
[1]  TRUE FALSE FALSE  TRUE


[[2]]
[1] "new1" "new2" "new3"


```  

这种方式可以把各个不同的数据类型的元素存储于一个list对象中.  

可以使用c( &lt;list对象&gt;, &lt;list对象&gt; ) 合并和扩展list, 注意list( &lt;list对象&gt;, &lt;list对象&gt; )不能进行list合并, 它是实现list的嵌套.  
```  
> l<-list( a = c(1, 2, 3), b = c("one", "two"), c = T, d = c(3i+4, 9i-9))

> l<-c(l, list( e = c(106:101) ))
> l
$a
[1] 1 2 3

$b
[1] "one" "two"

$c
[1] TRUE

$d
[1]  4+3i -9+9i

$e
[1] 106 105 104 103 102 101



```  

unlist函数可以把列表对象转化为向量对象, 转化后元素的数据类型被统一.  
```  
> l<-list( a = c(1, 2, 3), b = c("one", "two"), c = T, d = c(3i+4, 9i-9))

> v1<-unlist(l)
> mode(v1)
[1] "character"


```  




### 数据框 data.frame ###

笔者认为, 数据框是仅次于向量的最重要的数据对象类型. 在R语言中, 很多数据分析算法函数的输入都是数据框对象. 在使用Excel/TXT等格式数据集的函数时, 也是以数据框对象输出的. 类似于list, 数据框也可以由不同的向量作为列来合成. 并且不同列间的元素可以是不同的数据类型. 但是数据框并没有list那么灵活, 数据框内每个列的长度必须相同.  

在实际操作中, 通常会用数据框的一列代表某一变量的所有取值, 用一行代表某一样本数据.  


data.frame函数可以直接把多个向量建立为一个数据框, 并为列设置名称.  
```  
> d_frame<-data.frame(
+   day = c("02-01", "02-02", "02-04", "02-05"),
+   pv = c(1001, 1002, 1004, 1005),
+   uv = c(101, 102, 104, 105),
+   times = c(51, 52, 44, 66) )

> d_frame
    day   pv  uv times
1 02-01 1001 101    51
2 02-02 1002 102    52
3 02-04 1004 104    44
4 02-05 1005 105    66


```  

除了使用向量组成数据框外, 还可以通过data.frame函数把matrix转化为数据框.  
```  
> d_matrix<-matrix(1:12, c(3, 4))
> d_matrix
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

> d_f1<-data.frame(d_matrix)
> d_f1
  X1 X2 X3 X4
1  1  4  7 10
2  2  5  8 11
3  3  6  9 12

```  

可以通过names( &lt;数据框&gt; ) 来读取并编辑列名称.  
```  
> d_matrix<-matrix(1:12, c(3, 4))
> d_f1<-data.frame(d_matrix)

> names(d_f1)
[1] "X1" "X2" "X3" "X4"

> names(d_f1)[1]<-"col1"

> names(d_f1)
[1] "col1" "X2"   "X3"   "X4"


```  

数据框的索引和矩阵类似, 由于都是二维数据, 所以它也有两个维度的下标. 同时数据框的列名称也可以方便地索引数据框的列数据.  
&lt;数据框对象&gt;$列名称  
&lt;数据框对象&gt;[["列名称"]]  
&lt;数据框对象&gt;[[列下标]]  
&lt;数据框对象&gt;[, 列下标]  

```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)
> d_f2
   X1  X2  X3  X4  X5
1 101 105 109 113 117
2 102 106 110 114 118
3 103 107 111 115 119
4 104 108 112 116 120


> d_f2$X1
[1] 101 102 103 104

> d_f2[["X1"]]
[1] 101 102 103 104

> d_f2[[1]]
[1] 101 102 103 104


> d_f2[, 1]
[1] 101 102 103 104


> d_f2[, 1:2]
   X1  X2
1 101 105
2 102 106
3 103 107
4 104 108

> d_f2[, 2:4]
   X2  X3  X4
1 105 109 113
2 106 110 114
3 107 111 115
4 108 112 116


```  

想读取多列的数据, 则可以以 &lt;数据框对象&gt;[, 列下标向量] 方式来获取元素, 并以数据框对象的形式返回. 注意, 不可以采用 &lt;数据框对象&gt;[[列下标向量]] 形式.  

通过 &lt;数据框对象&gt;[行下标, ] , 可以直接获取相应行的所有元素, 并以数据框对象的形式返回.  
```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)

> d_f2[1:3, ]
   X1  X2  X3  X4  X5
1 101 105 109 113 117
2 102 106 110 114 118
3 103 107 111 115 119
> d_f2[2, ]
   X1  X2  X3  X4  X5
2 102 106 110 114 118


> m1<-as.matrix(d_f2)[1:3, ]
> m1
      X1  X2  X3  X4  X5
[1,] 101 105 109 113 117
[2,] 102 106 110 114 118
[3,] 103 107 111 115 119

```  

想要返回向量形式的数据, 则要先把数据框转化为矩阵再进行索引.  

数据框的列索引可以返回一个向量对象, 再继续索引向量进而索引某一元素. 4种方式索引列的某一个元素.  
```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)

> d_f2$X2[1]
[1] 105

> d_f2[["X2"]][1]
[1] 105

> d_f2[[2]][1]
[1] 105

> d_f2[1, 2]
[1] 105

```  

除了索引一个元素, 还可以索引一块元素.  例如:  
```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)


> d_f2[1:4, c(1, 3, 2)]
   X1  X3  X2
1 101 109 105
2 102 110 106
3 103 111 107
4 104 112 108


```  

subset函数可以方便地索引元素, 该函数同样可以应用于数据框中.  
```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)

> subset( d_f2, X2 > 105 & X2 < 110)
   X1  X2  X3  X4  X5
2 102 106 110 114 118
3 103 107 111 115 119
4 104 108 112 116 120

> subset( d_f2, X2 > 105 & X2 < 110, X4)
   X4
2 114
3 115
4 116


```  


使用cbind和rbind函数可以合并扩展矩阵, 它们同样也适用于数据框.  
```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)

# 增加样本数据 (添加一行数据)
> d_f2<-rbind(d-f2, list(1001, 1002, 1003, 1004, 1005))


# 增加数据集新属性 (添加一列数据)
> d_f2<-cbind(d_f2, col = c(2001:2005))

```  


数据框删除操作的实质是对数据框进行重新赋值, 只要所赋值的值内不包含欲删除的行或列的元素即可.  
```  
> demo_matrix<-matrix(101:120, c(4, 5))
> d_f2<-data.frame(demo_matrix)
> d_f2
   X1  X2  X3  X4  X5
1 101 105 109 113 117
2 102 106 110 114 118
3 103 107 111 115 119
4 104 108 112 116 120

# delete a column
> d_f2<-d_f2[, -1]
> d_f2
   X2  X3  X4  X5
1 105 109 113 117
2 106 110 114 118
3 107 111 115 119
4 108 112 116 120

# delete a row
> d_f2<-d_f2[-1, ]
> d_f2
   X2  X3  X4  X5
2 106 110 114 118
3 107 111 115 119
4 108 112 116 120


```  

na.omit 函数同样适用于数据框的缺失值处理, 使用 na.omit函数可以删除数据框内包括NA相关行数据.  
```  
> df1<-data.frame( a = c(11, 21, NA, 41), b = c(9:12), c = c("v1", "v2", "v3", "v4"))
> df1
   a  b  c
1 11  9 v1
2 21 10 v2
3 NA 11 v3
4 41 12 v4

> na.omit(df1)
   a  b  c
1 11  9 v1
2 21 10 v2
4 41 12 v4


```  
直接删除了包括NA的行数据. 也可以理解为该数据集中, 第3个样本中的a变量数据是NA, 因此直接删除了该样本.  


## 因子 ##


在研究数据时, 一般可以把数据分为分类和数值两种属性.  

<table>
  <tr>
    <th colspan="2">属性类型</th>  <th>描述</th>  <th>例子</th>  <th>R语言描述</th>
  </tr>
  
  <tr>
    <td rowspan="2">分类(定性)</td>  
	<td>标称</td>  <td>标称属性的数值仅是不同的名称, 即标称值只提供区分对象的信息(可以进行等于或不等于比较)</td>  <td>用户ID</td>  <td>无序因子factor</td>
  </tr>
  <tr>
    <td>序数</td>  <td>序数属性的值信息可以确定对象的序(可以进行大于或小于比较)</td>  <td>用户对商品的评分值</td>  <td>有序因子ordered</td>
  </tr>
  
  <tr>
    <td rowspan="2">数值(定量)</td>
	<td>区间</td>  <td>对于区间属性, 值之间的差有意义, 即存在测量单位(可以进行加减)</td>  <td>日期</td>  <td rowspan="2">实数</td>
  </tr>
  <tr>
    <td>比率</td>  <td>比率变量, 差和比率均有意义(可以进行乘除)</td>  <td>页面浏览量</td>  
  </tr>
  
</table>


factor函数可以把向量编码为一个因子.  
` factor(x, levels = sort( unique(x), na.last = TRUE ), labels, exclude = NA, ordered = FALSE) `  

参数说明
<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>x</td>  <td>向量</td>
  </tr>
  <tr>
    <td>levels</td>  <td>是因子的水平, 如果不指定值, 则由向量x内不同的值确定.</td>
  </tr>
  <tr>
    <td>labels</td>  <td>是水平标签, 如果不指定值, 则由向量x内不同的值所对应的字符串确定.</td>
  </tr>
  <tr>
    <td>exclude</td>  <td>在转化时, 如果想把向量内某些取值的元素转化为缺失值NA, 则设置该参数</td>
  </tr>
  <tr>
    <td>ordered</td>  <td>如果取FALSE(默认取值), 则转化后是无序因子; 如果取TRUE, 则转化后是有序因子.</td>
  </tr>
  
</table>


```  
> f1<-factor(c(1:9))
> f1
[1] 1 2 3 4 5 6 7 8 9
Levels: 1 2 3 4 5 6 7 8 9


> f2<-factor(c(1:9), exclude = c(2, 6, 8), ordered = TRUE)
> f2
[1] 1    <NA> 3    4    5    <NA> 7    <NA> 9   
Levels: 1 < 3 < 4 < 5 < 7 < 9


```  




使用as.factor把一个向量转化为无序因子向量.  

```  
> fc<-as.factor( c(101:106) )
> fc
[1] 101 102 103 104 105 106
Levels: 101 102 103 104 105 106

> fc[1] == fc[2]
[1] FALSE

> fc[1] > fc[2]
[1] NA
Warning message:
In Ops.factor(fc[1], fc[2]) : ‘>’ not meaningful for factors


```  

使用as.factor转化的无序因子不能进行大于小于比较, 只能进行等于和不等于比较.  

使用as.ordered转化的有序因子可以进行大于, 小于的比较操作.  
```  
> o1<-as.ordered( c(101:106) )
> o1
[1] 101 102 103 104 105 106
Levels: 101 < 102 < 103 < 104 < 105 < 106

> o<-as.ordered( c("v1", "v2", "v3", "v4", "v5") )
> o
[1] v1 v2 v3 v4 v5
Levels: v1 < v2 < v3 < v4 < v5

> o2<-as.ordered( c("v1", "v2", "v3", "v4", "v5", "v6") )
> o2
[1] v1 v2 v3 v4 v5 v6
Levels: v1 < v2 < v3 < v4 < v5 < v6

> o2[1] == o2[2]
[1] FALSE
> o2[1] > o2[2]
[1] FALSE


```  

is.factor函数用于判断向量是否为无序因子, is.ordered函数用于判断向量是否为有序因子.  
```  
> f1<-as.factor( c(201:206) )
> o1<-as.ordered( c(201:206) )

> is.factor(f1)
[1] TRUE
> is.ordered(f1)
[1] FALSE

> is.factor(o1)
[1] TRUE
> is.ordered(o1)
[1] TRUE

```  

levels(&lt;因子向量&gt;) 以向量的形式读取因子水平对应的字符串, 同时可以直接编辑修改.  
```  
> fc1<-factor( c(201:206) )
> fc1
[1] 201 202 203 204 205 206
Levels: 201 202 203 204 205 206
> levels(fc1)
[1] "201" "202" "203" "204" "205" "206"


> levels(fc1)[1]<-"one"
> fc1
[1] one 202 203 204 205 206
Levels: one 202 203 204 205 206


> levels(fc1)<- c("lv1", "lv2", "lv3", "lv4", "lv5", "lv6")
> fc1
[1] lv1 lv2 lv3 lv4 lv5 lv6
Levels: lv1 lv2 lv3 lv4 lv5 lv6


```  

对于初学者来说, 一个常见的错误就是为某一个因子元素赋予了水平中没有的数值.  

```  
> fc1[1]<-"a"
Warning message:
In `[<-.factor`(`*tmp*`, 1, value = "a") :
  invalid factor level, NA generated

> fc1[1]<-"lv4"
> fc1
[1] lv4 lv2 lv3 lv4 lv5 lv6
Levels: lv1 lv2 lv3 lv4 lv5 lv6

```  


cut函数可以把数值类型, 依据间隔区间分段, 并返回一个因子序列.  
```  
> t<-c(10, 11, 12, 9, 8, 7, 6, 5, 10, 20, 30, 40, 21, 22, 23, 25)

> tc<-cut(t, breaks = c(0, 5, 10, 20, 30))
> tc
 [1] (5,10]  (10,20] (10,20] (5,10]  (5,10]  (5,10]  (5,10]  (0,5]   (5,10]  (10,20] (20,30] <NA>    (20,30] (20,30] (20,30] (20,30]
Levels: (0,5] (5,10] (10,20] (20,30]


> tc[1] <tc[2]
[1] NA
Warning message:
In Ops.factor(tc[1], tc[2]) : ‘<’ not meaningful for factors


> tc1<-cut(t, breaks = c(0, 5, 10, 20, 30), ordered_result = T )
> tc1[1] > tc1[2]
[1] FALSE



```  

cut分割区间返回了无大小意义的因子向量, 在比较两个元素时, 返回了错误提示.  设置 ordered_result参数为T后, 返回的因子向量具有了大小意义.  

通过labels参数, 可以设置返回的因子向量的水平值.  
```  
> t<-c(10, 11, 12, 9, 8, 7, 6, 5, 10, 20, 30, 40, 21, 22, 23, 25)

> tc2
 [1] 2    3    3    2    2    2    2    1    2    3    4    <NA> 4    4    4    4   
Levels: 1 2 3 4

```  



## 字符串 ##

length(&lt;向量&gt;) 可以读取向量内的数目, 但无法读取一个字符串的实际长度. 这时需要用到nchar函数, 通过该函数可以读取字符串内部的字符数目.  
```  
> nchar("value test")
[1] 10
> nchar("8点45分")
[1] 5

```  

paste函数用于合并字符串, 基本形式为 paste(&lt;字符串&gt; ... , sep = "").  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>&lt;字符串&gt; ...</td>  <td>字符串或者字符串对象</td>
  </tr>
  <tr>
    <td>sep</td>  <td>链接多个字符串, 中间的间隔符, 默认为空格.</td>
  </tr>
</table>   

```  
> s1<-paste("今天天气", "晴", "18摄氏度", "微风", sep = "")
> s1
[1] "今天天气晴18摄氏度微风"

> s2<-paste("今天天气", "晴", "18摄氏度", "微风", sep = " -> ")
> s2
[1] "今天天气 -> 晴 -> 18摄氏度 -> 微风"

```  

strsplit函数可依据特定字符串把字符串分割为列表, 其中用于分割的字符串将不再出现.  
```  
> sd<-"今天是: 2016-03-01 时间 12:30:45"
> s1<-strsplit(sd, split = ":")
> s1
[[1]]
[1] "今天是"              " 2016-03-01 时间 12" "30"                  "45"                 


> slist<-unlist(s1)
> slist
[1] "今天是"              " 2016-03-01 时间 12" "30"                  "45"                 
> slist[1]
[1] "今天是"
> slist[2]
[1] " 2016-03-01 时间 12"


```  

笔者通常使用 unlist(strsplit(&lt;字符串&gt;, split = &lt;分割符&gt;)) 函数. 并依据分割符来把一个字符串分割为多个字符串的向量.  


substr函数可以直接读取/替换字符串中的一段子字符串.  
` substr(x, start, stop) `  

substr函数说明.  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>x</td>  <td>字符串或者字符串对象</td>
  </tr>
  <tr>
    <td>start</td>  <td>预读取/替换字符串的第一个下标</td>
  </tr>
  <tr>
    <td>stop</td>  <td>预读取/替换字符串的最后一个下标</td>
  </tr>
</table>


```  
> s1<-"Hello World!"
> s1
[1] "Hello World!"
> substr(s1, 2, 4)
[1] "ell"


> substr("今天是星期一, 天气晴朗", 3 , 6)
[1] "是星期一"


> substr(s1, 2, 4) <-"test"
> s1
[1] "Hteso World!"

> substr(s1, 2, 4) <- "ok?"
> s1
[1] "Hok?o World!"

```  


grep(pattern, x)函数可以在字符型列表(参数x)中找出和特定字符串(参数pattern)匹配的序列编号. 如果不匹配, 返回integer(0), 其长度 length(grep(pattern, x))==0. 其中pattern可以是字符串, 也可以是一个正则表达式.  

```  
> slist<-list("CURL value1.html HTTP/1.0", "Curl value2.htm HTTP/2.0")
> slist
[[1]]
[1] "CURL value1.html HTTP/1.0"

[[2]]
[1] "Curl value2.htm HTTP/2.0"

> g1<-grep(".html", slist)
> g1
[1] 1

> g2<-grep("test", slist)
> g2
integer(0)

> g3<-grep("value", slist)
> g3
[1] 1 2


```  


如果a不是字符型列表, 而是一个字符串, 则grep可用于判别该字符串中是否包含特定的字符串. 如果包含, 则返回1. 不包含则返回integer(0).  
```  
> s1<-"CURL value1.html result 512KB bytes"
> g1<-grep(".html", s1)
> g1
[1] 1

> g2<-grep("test", s1)
> g2
integer(0)

```  


regexpr(pattern, text) 函数可以在字符串x中提取出特定的字符串pattern的相关信息. 其中pattern可以是字符串, 也可以是一个正则表达式.  

```  
> s1<-"curl value1.html return 512kb bytes"

> r1<-regexpr("value", s1)
> r1
[1] 6
attr(,"match.length")
[1] 5
attr(,"useBytes")
[1] TRUE

```  

regexpr() 函数只匹配第一个特定的字符, 想要多次匹配需要使用gregexpr()函数.  

```  
> s1<-"curl value1.html return 512kb bytes, curl value2.html return 1024kb bytes"

> g1<-gregexpr("value", s1)
> g1
[[1]]
[1]  6 43
attr(,"match.length")
[1] 5 5
attr(,"useBytes")
[1] TRUE

```  



chartr() 函数可以直接进行字符的替换, 其查询的规则将以被替换字符串的形式给出.  
` chartr(old, new, x) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>x</td>  <td>字符串或字符串对象</td>
  </tr>
  <tr>
    <td>old</td>  <td>预被替换的x中的旧字符串集合. 如果x字符串中不包括old字符串集合, 则函数仍返回x字符串. 不做任何处理.</td>
  </tr>
  <tr>
    <td>new</td>  <td>替换处理后, 新补充的字符串集合. 长度必须大于等于旧字符串集合.</td>
  </tr>
</table>


```  
> s1<-"Test Hello World!"

> c1<-chartr("va", "kk", s1)
> c1
[1] "Test Hello World!"


> c2<-chartr("lo", "k", s1)
Error in chartr("lo", "k", s1) : 'old'比'new'要长

> c3<-chartr("lo", "ab", s1)
> c3
[1] "Test Heaab Wbrad!"

> c4<-chartr("lo", "abc", s1)
> c4
[1] "Test Heaab Wbrad!"

```  

对应每个字符都替换了, 不是在字符串中截取并替换.  



chartr()替换的单位是字符, sub()或gsub()函数的替换单位则是字符串. sub函数基本形式:  
` sub(pattern, replacement, x) `  


<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>pattern</td>  <td>欲被替代的字符串, 可以使用正则表达式</td>
  </tr>
  <tr>
    <td>replacement</td>  <td>替代后的字符串</td>
  </tr>
  <tr>
    <td>x</td>  <td>原始字符串</td>
  </tr>
  
</table> 


```  
> s1<-"curl value1.html return 512kb bytes, curl value2.html return 1024kb bytes"

> sub1<-sub("value", "数据", s1)
> sub1
[1] "curl 数据1.html return 512kb bytes, curl value2.html return 1024kb bytes"

> sub2<-sub("value", "data", s1)
> sub2
[1] "curl data1.html return 512kb bytes, curl value2.html return 1024kb bytes"


```  

sub函数只对第一个匹配值进行替换, 想要全部替换可以使用gsub函数.  

```  
> s1<-"curl value1.html return 512kb bytes, curl value2.html return 1024kb bytes"

> g1<-gsub("value", "search", s1)
> g1
[1] "curl search1.html return 512kb bytes, curl search2.html return 1024kb bytes"

```  


**正则表达式**  

[] 表示字符集合  

[aeiou]  匹配任何一个英文元音字母  
[0-9]  匹配任意一个数字, 0到9  
[a-z]  匹配任意一个小写英文字母  
[A-Z]  匹配任意一个大写英文字母  
[a-z0-9A-Z_]  匹配任意一个字母, 数字或下划线  

小数点(.)或者逗号(,) 需要使用 `\\` 来取消这些字符的特殊意义.  使用`\\.`来匹配`.`.  


在正则表达式中可以使用限定符来指定数量.  

<table>
  <tr>
    <th>代码/语法</th>  <th>说明</th>	
  </tr>
  
  <tr>
    <td>*</td>  <td>重复0次或更多次</td>
  </tr>
  <tr>
    <td>+</td>  <td>重复一次或更多次</td>
  </tr>
  <tr>
    <td>?</td>  <td>重复0次或1次</td>
  </tr>
  <tr>
    <td>{n}</td>  <td>重复n次</td>
  </tr>
  <tr>
    <td>{n,}</td>  <td>重复n次或更多次</td>
  </tr>
  <tr>
    <td>{n,m}</td>  <td>重复n ~ m次</td>
  </tr>
  
</table>


## 常用数据的创建 ##

使用**gl**函数可以方便地创建一个**因子向量**.  
` gl(n, k, length = n * k, labels = 1:n , ordered = FALSE) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>n</td>  <td>因子水平的数目</td>
  </tr>
  <tr>
    <td>k</td>  <td>重复的次数</td>
  </tr>
  <tr>
    <td>`n * k`</td>  <td>向量长度, 默认`n * k`</td>
  </tr>
  <tr>
    <td>labels</td>  <td>因子水平的标签</td>
  </tr>
  <tr>
    <td>ordered</td>  <td>如果为FALSE(默认), 则因子向量是无序因子. 如果为TRUE, 则因子向量是有序因子.</td>
  </tr>
  
</table>

```  
> gl(3, 4, labels = c("v1", "v2", "v3")) 
 [1] v1 v1 v1 v1 v2 v2 v2 v2 v3 v3 v3 v3
Levels: v1 v2 v3

> gl(3, 2, length = 12, labels = c("v1", "v2", "v3"))
 [1] v1 v1 v2 v2 v3 v3 v1 v1 v2 v2 v3 v3
Levels: v1 v2 v3

```  


**等差数列**产生函数**seq**, 可产生等距间隔的数列.  
` seq(from = 1, to = 1, by = ( (to - from)/(length.out -1))) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>from</td>  <td>等差数列的首项数据, 默认为1</td>
  </tr>
  <tr>
    <td>to</td>  <td>等差数列的尾项数据, 默认为1</td>
  </tr>
  <tr>
    <td>by</td>  <td>等差的数值</td>
  </tr>
  <tr>
    <td>length.out</td>  <td>产生向量的长度</td>
  </tr>
  
</table>


```  
> seq(1, -9)
 [1]  1  0 -1 -2 -3 -4 -5 -6 -7 -8 -9

> seq(1, -9, by = -2)
[1]  1 -1 -3 -5 -7 -9

> seq(1, by = 2, length.out = 10)
 [1]  1  3  5  7  9 11 13 15 17 19

```  

在模拟实际数据情况时, 常常会使用随机抽样函数来从整体中挑出部分样本数据. 随机抽样又分为重复随机抽样和不重复随机抽样两种. 重复抽样是指, 本次从整体抽出的数据样本, 在下一次抽取时同样有机会被抽取. 不重复抽样就是, 一旦被抽取为样本, 下次就不能再被抽取了.  

**sample**函数可以完成**随机抽样**处理.  
` sample(x, size, replace = FALSE) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>x</td>  <td>整体数据, 以向量形式给出</td>
  </tr>
  <tr>
    <td>size</td>  <td>抽取样本的数目</td>
  </tr>
  <tr>
    <td>replace</td>  <td>如果为F(默认值), 则是不重复抽样. 此时size不能大于x的长度. 如果为T, 则是重复抽样, 此时size允许大于x的长度.</td>
  </tr>
</table>


```  
> sample(c(201:220), size = 10)
 [1] 203 216 207 204 217 220 201 212 215 214

> sample(c(201:220), size = 25, replace = T)
 [1] 204 213 213 208 219 216 218 211 220 204 206 206 206 216 208 216 209 212 202 210 216 203 210 212 215

```  


**rep**是**重复序列**函数, 其基本形式是rep(x, n). 其中, x是预重复的序列, 可以是任意数据类型的向量或数值. n是重复的次数.  

```  
> rep(1:9)
[1] 1 2 3 4 5 6 7 8 9
 
> rep(10:15, 4) 
 [1] 10 11 12 13 14 15 10 11 12 13 14 15 10 11 12 13 14 15 10 11 12 13 14 15
 
> rep(c("test1", "test2", "test3"), 3)
[1] "test1" "test2" "test3" "test1" "test2" "test3" "test1" "test2" "test3"
 
> rep(as.factor(c("因子1", "因子2", "因子3")), 3)
[1] 因子1 因子2 因子3 因子1 因子2 因子3 因子1 因子2 因子3
Levels: 因子1 因子2 因子3

```  

对于一个离散型变量X, 可以直接描述X取不同水平的概率值P{X}.  
借用微积分的思想, 可以计算变量X小于等于数值x0时的概率值 P{X<=x0}. 把点(x0, P{X<=x0}}连续化, 进而形成一条曲线, 用函数F(x)来表达该曲线, 它的意义是连续变量X小于等于x时的概率. 我们称该函数F(x)是变量X的分布函数. `F(x) = P{X<=x}`  
对F(x)做微分处理, 可以得到变量X的概率密度函数.  
对F(x)取反函数, 得到分位数函数.  



正态分布有两个参数, 平均值和方差, 其方差的平方根也称为标准差.  

使用` pnorm(x, mean, sd) ` 函数来表达时, 其中的参数x就是连续变量x, 参数mean是平均值, 参数sd是标准差. 其初始默认取值 `mean=0, sd =1 ` .  
概率密度函数使用 ` dnorm(x, mean, sd) ` 函数来表达.  
正态分布随机数的产生函数使用 ` rnorm(n, mean, sd) ` 来表达, 其中n是产生的随机数数目.  

```  
> rnorm(10, 5, 2) 
 [1]  3.8023551  4.1025205  8.0794033  6.2408178  4.6121950  7.0272276 11.2164345  5.0340282  1.8236069  0.7661015

> r1<-rnorm(10, 5, 2) 
> r1
 [1] 5.685253 4.250892 7.123485 4.959627 4.282455 4.854974 2.714526 6.099787 4.221002 6.810436


 
 > pnorm(r1, 5, 2)
 [1] 0.6340604 0.3539960 0.8558237 0.4919473 0.3598826 0.4710969 0.1265739 0.7088037 0.3484535 0.8173250
> pnorm(r1, 5, 1)
 [1] 0.75340801 0.22689598 0.98314338 0.48389779 0.23651890 0.44234526 0.01114252 0.86428744 0.21799034 0.96488587
 
> pnorm(c(1:5), 5, 1)
[1] 3.167124e-05 1.349898e-03 2.275013e-02 1.586553e-01 5.000000e-01
> pnorm(7, 5, 1)
[1] 0.9772499



> dnorm( r1, 5, 2)
 [1] 0.1880999 0.1859586 0.1135248 0.1994305 0.1870378 0.1989474 0.1038290 0.1714820 0.1848999 0.1324175


```  


R语言中其他常用分布函数.  

<table>
  <tr>
    <th>分布</th>  <th>在R中的名称</th>  <th>参数</th>
  </tr>
  
  <tr>
    <td>beta</td>  <td>beta</td>  <td>shape1, shape2, ncp</td>
  </tr>
  <tr>
    <td>binomial</td>  <td>binom</td>  <td>size, prob</td>
  </tr>
  <tr>
    <td>Cauchy</td>  <td>cauchy</td>  <td>location, scale</td>
  </tr>
  <tr>
    <td>chi-squared</td>  <td>shisq</td>  <td>df, ncp</td>
  </tr>
  <tr>
    <td>exponential</td>  <td>exp</td>  <td>rate</td>
  </tr>
  
  <tr>
    <td>F</td>  <td>f</td>  <td>df1, df2, ncp</td>
  </tr>
  <tr>
    <td>gamma</td>  <td>gamma</td>  <td>shape, scale</td>
  </tr>
  <tr>
    <td>geometric</td>  <td>geom</td>  <td>prob</td>
  </tr>
  <tr>
    <td>hypergeometric</td>  <td>hyper</td>  <td>m ,n, k</td>
  </tr>
  <tr>
    <td>log-normal</td>  <td>lnorm</td>  <td>meanlog, sdlog</td>
  </tr>
  
  <tr>
    <td>logistic</td>  <td>logis</td>  <td>location, scale</td>
  </tr>
  <tr>
    <td>negative</td>  <td>binomial</td>  <td>nbinom size, prob</td>
  </tr>
  <tr>
    <td>normal</td>  <td>norm</td>  <td>mean, sd</td>
  </tr>
  <tr>
    <td>Poisson</td>  <td>pois</td>  <td>lambda</td>
  </tr>
  <tr>
    <td>Student'st</td>  <td>t</td>  <td>df, ncp</td>
  </tr>
  
  <tr>
    <td>uniform</td>  <td>unif</td>  <td>min, max</td>
  </tr>
  <tr>
    <td>Weibull</td>  <td>weibull</td>  <td>shape, scale</td>
  </tr>
  <tr>
    <td>Wilcoxon</td>  <td>wilcox</td>  <td>m, n</td>
  </tr>
  
</table>


分布名称前添加前缀后可以代表不同的意义.  
> (1) p&lt;R中的分布名称&gt; 表示该分布的分布函数. 例如, pnorm是正态分布的分布函数.  
> (2) d&lt;R中的分布名称&gt; 表示该分布的概率密度函数, 例如, dnorm是正态分布的概率密度函数.  
> (3) q&lt;R中的分布名称&gt; 表示该分布的分位数函数. 例如, qnorm是正态分布的分位数函数.  
> (4) r&lt;R中的分布名称&gt; 表示该分布的随机序列产生函数. 例如, rnorm是正态分布的随机序列函数.  






## 控制流 ##

R包含所有串行语言都有的基本控制语句, 分支和循环.  

### if else ###

if-else分支  
```  
if(boolean) {
  // do something
} else {
  // do something
}


if(boolean) {
  // do something
} else if(boolean) {
  // do something
} else {
  // do something
}  
  
# demo

> v1<-5
> if ( v1 < 10 ) {
+   v1<-10
+ } else {
+   v1<-100
+ }

> v1
[1] 10



> v1<-5
> if ( v1 < 4 ) { 
+   v1<-1
+ } else if(v1 < 10 & v1 >= 4) {
+   v1<-9
+ } else {
+   v1<-100
+ }
> 
> v1
[1] 9



```  
通过if - else 语句可以组成多个分支判断语句, 如果处理语句中只包含一条语句, 则可以省略大括号{}.  



### switch ###

switch语句可以直接实现多分支语句, 但分支时并无判断的优先级区分.  
` switch(case, case 1 处理, case 2 处理, ..., case n 处理) `  

如果case对象等于n, 则执行第n条分支的case n处理. 如果case的取值大于list对象的长度, 则返回值是null.  
```  
> svalue<-3
> switch(svalue, "value1", "value2", "value3", "value4")
[1] "value3"
> svalue2<-9
> switch(svalue2, "value1", "value2", "value3", "value4")
> 

```  



### for循环 ###

在R语言中, 可以使用for, while以及repeat-break实现循环语句. 循环语句可以简单依据计数操作(当计数器达到了设定的循环次数时自动停止)或者某一向量来进行轮询.  

```  

> d1<-c(1, 1, 2, 3, 5, 7, 9, 11, 2, 4, 6)


> f1<-1
> rs1<-""
> for(i in d1) {
+   rs1[f1]<-as.character(i)
+   f1<-f1 + 1
+ }
> rs1
 [1] "1"  "1"  "2"  "3"  "5"  "7"  "9"  "11" "2"  "4"  "6" 


> f2<-1
> rs2<-""
> for(i in 1:length(d1)) {
+   rs2[f2]<-as.character(d1[i])
+   f2<-f2 + 1
+ }
> 
> rs2
 [1] "1"  "1"  "2"  "3"  "5"  "7"  "9"  "11" "2"  "4"  "6" 

 
 
```  


### while循环 ###

```  
> d1<-c(1, 1, 2, 3, 5, 7, 9, 11, 2, 4, 6)
> i<-1
> wrs1<-""
> while( i < length(d1) ) {
+   wrs1[i]<-as.character(d1[i])
+   i<-i + 1
+ }

> wrs1
 [1] "1"  "1"  "2"  "3"  "5"  "7"  "9"  "11" "2"  "4" 

```  

for实际上是通过遍历一个向量的方式来控制循环次数. while则是直接设置循环的范围. for的应用基本可以覆盖while. 笔者更加倾向于使用for循环语句.  





### repeat break循环 ###

repeat是无限循环语句, 并且会在达到循环条件后使用break语句直接跳出循环.  

```  
> d1<-c(1, 1, 2, 3, 5, 7, 9, 11, 2, 4, 6)
> p1<-1
> prs1<-""
> repeat {
+   if( p1 > length(d1)) {
+     break;
+   } else {
+     prs1[p1]<-as.character(d1[p1])
+   } 
+   p1<-p1 + 1
+ }

> prs1
 [1] "1"  "1"  "2"  "3"  "5"  "7"  "9"  "11" "2"  "4"  "6" 


```  

R语言还提供了next语句, 执行后只会跳出本次循环, 而不会跳出整个循环.  


## 运算符, 函数, 过程 ##

算术运算符  

<table>
  <tr>
    <th>运算符</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td> + </td>  <td>加</td>
  </tr>
  <tr>
    <td> - </td>  <td>减</td>
  </tr>
  <tr>
    <td> * </td>  <td>乘</td>
  </tr>
  <tr>
    <td> / </td>  <td>除</td>
  </tr>
  
  <tr>
    <td> ^ 或 ** </td>  <td>幂运算</td>
  </tr>
  <tr>
    <td> x %% y </td>  <td>求除法运算得到的余数, 如 10 %% 3 结果为1</td>
  </tr>
  <tr>
    <td> x %/% y </td>  <td>整数除法, 例如 10 %/% 3 结果为3 </td>
  </tr>
  
</table>


逻辑运算符  

<table>
  <tr>
    <th>运算符</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td> < </td>  <td>小于</td>
  </tr>
  <tr>
    <td> <= </td>  <td>小于等于</td>
  </tr>
  <tr>
    <td> > </td>  <td>大于</td>
  </tr>
  <tr>
    <td> >= </td>  <td>大于等于</td>
  </tr>
  <tr>
    <td> == </td>  <td>等于</td>
  </tr>
  
  <tr>
    <td> != </td>  <td>不等于</td>
  </tr>
  <tr>
    <td> !x </td>  <td>非x</td>
  </tr>
  <tr>
    <td> x | y </td>  <td>x或y(并集)</td>
  </tr>
  <tr>
    <td> x & y </td>  <td>x和y(交集)</td>
  </tr>
  <tr>
    <td> isTRUE(x) </td>  <td>测试x是否为TRUE</td>
  </tr>
  
</table>


自定义函数的格式如下:  
` func.name<-function(arg_1, arg_2, ...) expression `  

其中func.name为函数的名称, arg_1和arg_2是函数的输入参数. expression是R语言的表达式, 在定义函数时, 可以为某些参数直接设置初始值. 在定义好函数后, 可以使用 func.name(arg_1 = value1, arg_2 = value2, ...)来调用函数. 已经设置好了参数的初始值, 则在调用时可以不为参数设置数值.  

```  
> demo.func<-function( x1, x2 = 0) {
+   if( (x1 + x2) > 100 ) {  
+     rlt = x1 + x2 + 100
+   } else if ( (x1 + x2) >= -90 ) {
+     rlt = x1 + x2
+   } else {
+     rlt <- NA 
+   }
+   rlt
+ }


> demo.func(1, 5)
[1] 6
> demo.func(x1 = 50, x2 = 51)
[1] 201
> demo.func(x1 = -31, x2 = -60)
[1] NA

```  

在函数内部定义的数据对象(包括以参数形式定义的数据对象) 均为局部变量, 因此不会改变函数外部同名对象的数值.  


过程和函数类型, 只是函数内部的对象是局部变量, 而过程内部对象的赋值均是全局性操作. 另外在表现形式上, 过程和函数有很大的区别. 由于过程内部全部是全局变量操作, 所以输入参数和返回值对于过程而言没有任何意义. 即过程无输入参数的概念, 也无返回值的概念. 只有函数才有.  

使用 expression 函数定义一个过程.  

```  
> demo.ex<-expression (
+   if( m > 0 & n > 0 ) {
+     m<- m + n
+     n<-1
+   } else if ( m > 0 & n < 0 ) {
+     m<- m - n
+     n<-2
+   } else if ( m < 0 & n > 0 ) {
+     m<- n - m
+     n<-3
+   } else if ( m < 0 & n < 0 ) {
+     m< - m - n
+     n<-4
+   } else {
+     m<--1
+     n<-0
+   }
+ )
> 
> ls()
[1] "demo.ex"


> eval(demo.ex)
Error in eval(expr, envir, enclos) : 找不到对象'm'


> m<-5
> n<-15
> 
> eval(demo.ex)
> m
[1] 20
> n
[1] 1


```  

 
## 数据的读写操作 ##


read.table 函数可以读取外部数据至一个数据框对象中.  
` read.table(file, header = FALSE, sep = "", encoding = "unknown", ...) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>file</td>  <td>file是一个字符串, 代表读取的数据文件.</td>
  </tr>
  <tr>
    <td>header</td>  <td>如果为FALSE(默认取值), 则不把数据文件的第一行作为列名处理; 如果为TRUE, 则把数据文件的第一行作为列名称处理.</td>
  </tr>
  <tr>
    <td>sep</td>   <td>设置用于区分不同列的分隔符, 默认为空格, 对制表符分隔的文件使用 sep = "\t".</td>
  </tr>
  <tr>
    <td>encoding</td>  <td>编码, 为防止中文乱码, 可以设置 encoding = "UTF-8".</td>
  </tr>
  <tr>
    <td>as.is</td>  <td>用于设置是否把字符类型的列数据(未转化为实数复数和逻辑类型)转化为因子形式, 默认是FALSE, 即全部转化为因子. 如果设置为T, 则所有字符型列数据均不转化为因子. 另外, 还可以设置不需要转化的列序号.</td>
  </tr>
  
  <tr>
    <td>row.names</td>  <td>保存行名的向量, 或文件中一个变量的序号或名称, 缺失时行号取为 1, 2, 3, ...</td>
  </tr>
  <tr>
    <td>col.names</td>  <td>指定列名的字符型向量, 缺失值是 V1, V2, V3, ...</td> 
  </tr>
  <tr>
    <td>na.strings</td>  <td>代表缺失值的处理. (转化为NA)</td>
  </tr>
  <tr>
    <td>nrows</td>  <td>可以读取的最大行数. (忽略负值)</td>
  </tr>
  <tr>
    <td>skip</td>  <td>略过不读取前n行数据</td>
  </tr>
  
  <tr>
    <td>skip.white</td>  <td>在sep已指定的情况下, 如果为TRUE, 则删除字符型变量前后多余的空格.</td>
  </tr>
  <tr>
    <td>blank.lines.skip</td>  <td>如果为TRUE, 则忽略空白行</td>
  </tr>
  
</table>


```  
# demo file
id date time info
1001 2016-03-01 11:33:44 "curl value1.html return 512kb bytes"
1003 2016-03-02 13:34:45 "curl value2.html return false"
1004 2016-03-01 14:45:56 "post a form"


# read file 
> file1<-"c:/MyData/R/demo1/file/read_table.txt"

> read_table1<-read.table(file1, header = TRUE)

> read_table1
    id       date     time                                info
1 1001 2016-03-01 11:33:44 curl value1.html return 512kb bytes
2 1003 2016-03-02 13:34:45       curl value2.html return false
3 1004 2016-03-01 14:45:56                         post a form

> mode(read_table1)
[1] "list"

```  



当文件内的数据是固定宽度时, 可以使用函数 read.fwf 来读取.  
` read.fwf(file, widths, sep = "\t", as.is = FALSE, ...) `  

read.fwf函数的参数与read.table类似, 只是read.fwf函数还有一个特殊的 widths 参数用于设定不同列的宽度.  

```  
# read.fwf demo file
1001 2016-03-01 01:00:00 POST 200
1002 2016-03-01 02:00:00 POST 201
1003 2016-03-02 02:00:00 POST 200



> file2<-"C:/MyData/R/demo1/file/read_fwf.txt"

> read_fwf1<-read.fwf(file2, widths=c(5, 11, 9, 5, 3))

> read_fwf1
    V1          V2        V3    V4  V5
1 1001 2016-03-01  01:00:00  POST  200
2 1002 2016-03-01  02:00:00  POST  201
3 1003 2016-03-02  02:00:00  POST  200

> mode(read_fwf1)
[1] "list"


```  


scan函数读取外部文件时有如下特点:  
> (1) scan函数可以指定输出变量的数据类型.  
> (2) 输出对象的类型更灵活, 可以是数据框, 向量, 矩阵, 列表.  
> (3) 对于很大的数据文件, 使用scan函数时读取速度会更快, 因为它可以事先设定数据类型, 而不是在读取完毕后再检查数据类型的一致性.  

scan参数说明  

<table>
  <tr>
    <td>参数</td>  <td>说明</td>
  </tr>
  
  <tr>
    <td>file</td>  <td>字符串, 文件位置</td>
  </tr>
  <tr>
    <td>what</td>  <td>在读取后, 用于说明各列数据的类型, 可使用logical, integer, numeric, complex, character, raw和list等函数</td>
  </tr>
  <tr>
    <td>sep</td>  <td>分隔符, 默认为空格</td>
  </tr>
  <tr>
    <td>skip</td>  <td>略过不读取前n行数据.</td>
  </tr>
  <tr>
    <td>nlines</td>  <td>要读取的行数</td>
  </tr>
  
  <tr>
    <td>encoding</td>  <td>编码, 防止中文乱码, 可设置 encoding = "UTF-8"</td>
  </tr>
  <tr>
    <td>na.strings</td>  <td>代表缺失数据的值.(转化为NA)</td>
  </tr>
  
</table>


```  
# scan demo file
@a001: 学习R语言 @b002 +1 @c003 分享 

R语言学习教程



 
> file3<-"C:/MyData/R/demo1/file/scan.txt"

> scan_data<-scan(file3, what = "character", sep = "@", encoding = "UTF-8")
Read 7 items

> scan_data
[1] "# scan "          ""                 "a001: 学习R语言 " "b002 +1 "         "c003 分享 "       "R语言学习教程"    " "               

> mode(scan_data)
[1] "character"


```  



CSV(逗号分隔)文件是较为常用的数据文件格式, 通过 read.csv函数可以读取CSV文件并返回一个数据框对象.  


 
```  
# 准备一个CSV文件


> file4<-"C:/MyData/R/demo1/file/read_csv.csv"

> data_csv<-read.csv(file4)

> data_csv
  序列号     日期     时间      反馈
1   1001 2016/3/1 10:22:33      Good
2   1002 2016/3/2 12:34:45      不错
3   1003 2016/3/1  9:05:56 Very Good

> mode(data_csv)
[1] "list"


```  


使用RODBC包可以读取Excel格式文件, 其核心函数分别是odbcConnectExcel和sqlFetch.  

```  
> setwd("C:/MyData/R/demo1")
> getwd()
[1] "C:/MyData/R/demo1"

> .libPaths()
[1] "C:/Program Files/R/R-3.2.4revised/library"

# window 10下, 需要使用管理员身份运行R
> install.packages("RODBC")

> library(RODBC)

> file4<-"C:/MyData/R/demo1/file/read_excel.xls"
> excel_file<-odbcConnectExcel(file4)
> excel_sheet1<-sqlFetch(excel_file, "read_csv")

> excel_sheet1
  序列号       日期                时间      反馈
1   1001 2016-03-01 1899-12-30 10:22:33      Good
2   1002 2016-03-02 1899-12-30 12:34:45      不错
3   1003 2016-03-01 1899-12-30 09:05:56 Very Good
> 
> mode(excel_sheet1)
[1] "list"

# 需要在32位环境下使用 odbcConnectExcel, 只能读取.xls文件, 不能读取.xlsx文件


> excel_file<-odbcConnectExcel(file4)
Error in odbcConnectExcel(file4) : 
  odbcConnectExcel is only usable with 32-bit Windows

  
```  



对于向量和矩阵的输出, 一般使用write函数写入某一文件中.  
` write(x, file, append = FALSE) `  

<table>
  <tr>
    <th>参数</th>  <th>说明</th>
  </tr>
  
  <tr>
    <td>x</td>  <td>数据源, 一般是向量或矩阵类型的数据对象.</td>
  </tr>
  <tr>
    <td>file</td>  <td>输出的文件</td>
  </tr>
  <tr>
    <td>append</td>  <td>如果是FALSE(默认的值), 则清空file文件内的原有数据, 再写入x的内容. 如果是TRUE, 则在file文件原有内容的基础上追加写入x的内容.</td>
  </tr>
  
  
</table>


对于列表或数据框类型对象, 建议使用write.table写入文本文件中, 或者使用write.csv写入csv文件中. 基本参数与write类似.  

```  
> c1<-c(201:210)
> m1<-matrix(1:12, c(3,4))
> df1<-data.frame(m1)


> write(c1, "C:/MyData/R/demo1/output/c1.txt")

> write(m1, "C:/MyData/R/demo1/output/m1.txt")

> write(df1, "C:/MyData/R/demo1/output/df1.txt")
Error in cat(list(...), file, sep, fill, labels, append) : 
  cat目前还不能处理1(种类为'list')参数
  
> write.table(df1, "C:/MyData/R/demo1/output/table_df1.txt")

> write.csv(df1, "C:/MyData/R/demo1/output/csv_df1.txt")

> write.csv(df1, "C:/MyData/R/demo1/output/csv_df1.csv")


```  



cat函数可以把R语言命令输出至一个外部文件, 然后通过source函数运行该批处理文件.  
` cat(..., file = "", sep = "", append = FALSE) `  

其中, ...是预输出的命令, 其他参数可以参考write函数的说明.  







 






 

   















































 








  





